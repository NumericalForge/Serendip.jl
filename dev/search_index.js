var documenterSearchIndex = {"docs":
[{"location":"manual/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"Serendip is a finite element library for research and engineering prototyping in Julia.","category":"section"},{"location":"manual/getting-started/#Install","page":"Getting Started","title":"Install","text":"using Pkg\nPkg.add(\"Serendip\")\n\nFor local development in this repository:\n\nusing Pkg\nPkg.develop(path=\".\")","category":"section"},{"location":"manual/getting-started/#Load-package","page":"Getting Started","title":"Load package","text":"using Serendip","category":"section"},{"location":"manual/getting-started/#First-checks","page":"Getting Started","title":"First checks","text":"Pkg.test(\"Serendip\")","category":"section"},{"location":"manual/getting-started/#Documentation-scope","page":"Getting Started","title":"Documentation scope","text":"This documentation is currently organized in two tracks:\n\nA curated manual with workflows and practical guidance.\nA full API reference generated from exported symbols and docstrings.","category":"section"},{"location":"examples/overview/#Examples","page":"Overview","title":"Examples","text":"This section links to runnable examples in the repository.","category":"section"},{"location":"examples/overview/#Mechanical-examples","page":"Overview","title":"Mechanical examples","text":"examples/mech/static-3d.jl\nexamples/mech/dynamic.jl\nexamples/mech/beam-crack-2d.jl\nexamples/mech/reinforced-beam.jl\nexamples/mech/embedded-rebar.jl\nexamples/mech/composite-beam.jl\nexamples/mech/tensile-crack.jl","category":"section"},{"location":"examples/overview/#Notes","page":"Overview","title":"Notes","text":"These scripts are the source of truth for current APIs.\nDocs tutorial pages should explain selected scripts instead of duplicating full code.","category":"section"},{"location":"manual/workflow/#Workflow","page":"Workflow","title":"Workflow","text":"This page captures a recommended end-to-end workflow for mechanical analyses in Serendip.","category":"section"},{"location":"manual/workflow/#Typical-pipeline","page":"Workflow","title":"Typical pipeline","text":"Build or import geometry and mesh (GeoModel, Mesh, mesh transforms).\nDefine mappings from regions to element formulation + constitutive model (RegionMapper, add_mapping).\nConstruct the finite element model (FEModel).\nCreate an analysis (MechAnalysis or other analysis type).\nAdd stages, boundary conditions, monitors, and loggers.\nRun analysis and inspect output files/results.","category":"section"},{"location":"manual/workflow/#Minimal-sketch","page":"Workflow","title":"Minimal sketch","text":"using Serendip\n\n# Mesh and mapping\nmesh = Mesh(rand_mesh(2, 2))\nmapper = RegionMapper()\nadd_mapping(mapper, :all, MechBulk, LinearElastic; E=30e6, nu=0.2)\n\n# Model + analysis\nmodel = FEModel(mesh, mapper)\nana = MechAnalysis(model)\n\n# Stage and BCs\nstage = add_stage(ana)\nadd_bc(stage, :node, x==0, ux=0, uy=0, uz=0)\n\n# Solve\nrun(ana)\n\nNotes:\n\nUse selectors by tag/expr/geometry for robust BC assignment.\nPrefer RegionMapper APIs used in current examples/tests over legacy constructors.\nKeep scripts under examples/ as executable references, and mirror them in docs narrative pages.","category":"section"},{"location":"manual/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"This section is the curated, narrative side of the documentation.","category":"section"},{"location":"manual/tutorials/#Planned-tutorial-tracks","page":"Tutorials","title":"Planned tutorial tracks","text":"Geometry and meshing basics\nStatic mechanical analysis\nNonlinear constitutive models\nCohesive/contact modeling\nPost-processing and plotting","category":"section"},{"location":"manual/tutorials/#Draft-status","page":"Tutorials","title":"Draft status","text":"The previous long-form tutorial content exists in:\n\ndocs/src/tutorial/tutorial.md\n\nThat page is currently legacy content and needs API refresh before being re-enabled in navigation.","category":"section"},{"location":"manual/tutorials/#How-this-section-will-evolve","page":"Tutorials","title":"How this section will evolve","text":"Keep tutorials problem-oriented and minimal.\nReference real scripts in examples/ to reduce drift.\nAdd smaller executable blocks only when they are CI-stable.","category":"section"},{"location":"api/reference/#API-Reference","page":"Reference","title":"API Reference","text":"This page is generated from exported symbols in Serendip.","category":"section"},{"location":"api/reference/#Serendip.Serendip","page":"Reference","title":"Serendip.Serendip","text":"Serendip.jl\n\nSerendip module implements functions and types to perform finite element analyses.\n\nImportant data types\n\nNode, Element, Model, Dof, Ip, NodeBC, SurfaceBC\n\n\n\n\n\n","category":"module"},{"location":"api/reference/#Serendip.AsinhYieldCohesive","page":"Reference","title":"Serendip.AsinhYieldCohesive","text":"AsinhYieldCohesive(; E, nu=0.0, ft, fc, zeta=5.0, wc, GF, ft_law=:hordijk, alpha=1.5, gamma=0.1, theta=1.5)\n\nConstitutive model for cohesive elements with a power-lay yield surface ans ftlaw in tension.   The tensile ftlaw branch is regularized through a measure of the bulk element size h to ensure mesh-objective fracture energy dissipation.\n\nKeyword arguments\n\nE::Real:   Young’s modulus from the bulk material (must be > 0).\nnu::Real:   Poisson’s ratio (0 ≤ ν < 0.5).\nfc::Real:   Compressive strength (< 0).\nft::Real:  \nTensile strength (> 0).\nwc::Real:   Critical crack opening (must be > 0 if given). Can be specified alternatively to GF.\nmu::Real:   Friction coefficient (> 0).\nGF::Real:   Fracture energy (must be > 0 if given). Can be specified alternatively to wc.\nft_law::Union{Symbol,AbstractSpline} = :hordijk:   Softening law for post-peak tensile response. Options are: :linear, :bilinear, :hordijk, :soft or a custom function.\nalpha::Real = 0.6:   Parameter to control the shape of the yield surface (α > 0.5).\ngamma::Real = 0.1:   Parameter to control the residual shear strength (γ ≥ 0).\ntheta::Real = 1.5:   Parameter to control the rate of reduction of shear strength (θ ≥ 0).\nzeta::Real = 5.0:   Factor to control elastic relative displacements in cohesive formulations (≥ 0).\n\nReturns\n\nA AsinhYieldCohesive object.\n\nNotes\n\nEither wc or GF must be provided. If only GF is given, wc is computed internally based on the chosen ft_law.\nThe frictional contribution is governed by mu.\nNormal and shear stiffnesses (kn, ks) are computed from the mechanical properties of the bulk material and the characteristic length h of the adjacent bulk elements.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.CebBondSlip","page":"Reference","title":"Serendip.CebBondSlip","text":"CebBondSlip(; taumax, taures=0.0, s1, s2, s3, alpha=0.4, ks=taumax/s1, kn)\n\nConstitutive model for bond–slip behavior of a reinforcing bar embedded in a solid, according to the CEB (Comité Euro-International du Béton) formulation.\n\nParameters\n\ntaumax::Float64 : Peak shear strength (> 0).\ntaures::Float64 : Residual shear stress (≥ 0, must be < τmax).\ns1::Float64 : Characteristic slip defining the end of the ascending branch (> 0).\ns2::Float64 : Characteristic slip at the start of the softening branch (> 0).\ns3::Float64 : Characteristic slip where residual shear stress is reached (> 0).\nalpha::Float64 : Curvature parameter for the ascending branch (0 ≤ α ≤ 1, default 0.4).\nks::Float64 : Initial shear stiffness (default = τmax/s1, must satisfy ks ≥ τmax/s₁).\nkn::Float64 : Normal stiffness of the interface (> 0).\n\nNotes\n\nThe model defines the shear stress–slip relation in three branches: ascending (0–s1), softening (s2–s3), and residual plateau (≥ s3).\nDefault ks ensures consistency with the initial slope of the bond law.\nThe normal stiffness kn penalizes opening displacement at the interface.\n\nReferences\n\nCEB-FIP Model Code recommendations for bond–slip laws in reinforced concrete.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.Chart","page":"Reference","title":"Serendip.Chart","text":"Chart(; \n    size=(220,150), font=\"NewComputerModern\", font_size=7.0,\n    xlimits, ylimits, aspect_ratio=:auto,\n    xmult=1.0, ymult=1.0, xbins=7, ybins=6,\n    xlabel=\"$x$\", ylabel=\"$y$\",\n    xticks=Float64[], yticks=Float64[],\n    xtick_labels=String[], ytick_labels=String[],\n    legend=:top_right, legend_font_size=0,\n    quiet=false)\n\nConstruct a 2D chart figure with axes, legend, and optional tick customization.\n\nArguments\n\nsize::Tuple{Int,Int}: width × height in points. 1 cm = 28.35 points.\nfont::AbstractString: font family for axes and legend.\nfont_size::Real: base font size.\nxlimits::Vector{<:Real}, ylimits::Vector{<:Real}: axis limits [min,max]; use empty vectors for auto scaling.\naspect_ratio::Symbol: :auto or :equal.\nxmult::Real, ymult::Real: multiplicative factors applied to tick values.\nxbins::Int, ybins::Int: target number of major ticks.\nxlabel::AbstractString, ylabel::AbstractString: axis labels.\nxticks::Vector{<:Real}, yticks::Vector{<:Real}: explicit tick positions; empty vectors enable auto ticks.\nxtick_labels::Vector{<:AbstractString}, ytick_labels::Vector{<:AbstractString}: custom tick labels; if provided, lengths must match the corresponding tick arrays.\nlegend::Symbol: legend location (e.g., :top_right, :top_left, :bottom_left, :outer_right).\nlegend_font_size::Real: legend font size; 0 uses font_size.\nquiet::Bool: suppress constructor log.\n\nNotes\n\nUse add_series to append data series to the chart.\nUse save to export the chart to a file.\n\nReturns\n\nA Chart object.\n\nExample\n\nch = Chart(size=(300,200),\n           xlabel=\"Time [s]\",\n           ylabel=\"Displacement [mm]\",\n           xlimits=[0.0,10.0],\n           ylimits=[-5.0,5.0],\n           legend=:bottom_right)\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.Context","page":"Reference","title":"Serendip.Context","text":"Context(; ndim=3, stress_state=:auto, transient=nothing, thickness=1.0, g=0.0, T0=0.0)\n\nDefines global analysis metadata and configuration parameters for the finite element model.\n\nThis struct encapsulates the physical and numerical context in which the FE model is defined, including dimensionality, stress state, analysis type, and environmental parameters such as gravity and reference temperature.\n\nKeyword Arguments\n\nndim::Int=3: Number of spatial dimensions.\n3 for 3D analysis.\n2 for 2D analysis.\nstress_state::Symbol=:auto: Stress state for 2D problems. Accepted values:\n:auto — Automatically determined from geometry and settings.\n:plane_stress — Plane stress assumption (e.g., thin plates).\n:plane_strain — Plane strain assumption (e.g., long tunnels).\n:axisymmetric — Axisymmetric assumption for rotationally symmetric models.\ntransient::Flag=nothing: Flag for transient analysis. Accepted values:\ntrue — Transient (time-dependent) analysis.\nfalse — Steady-state analysis.\nnothing — Auto-detect based on problem setup.\nthickness::Float64=1.0: Thickness for 2D analyses. Ignored for 3D problems.\ng::Float64=0.0: Gravity acceleration.\nT0::Float64=0.0: Reference temperature for thermal effects (if applicable).\n\nExample\n\nctx = Context(ndim=2, stress_state=:plane_strain, thickness=0.1, g=9.81)\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.CyclicBondSlip","page":"Reference","title":"Serendip.CyclicBondSlip","text":"CyclicBondSlip(; taumax, taures, speak, sres, alpha=0.4, beta=1.0, ks, kn, p)\n\nConstitutive model for a cyclic rod–solid bond interface with degradation. The shear bond law uses a piecewise envelope: power-law hardening up to speak, a short plateau, then softening toward taures. Under cyclic loading, the envelope evolves with the reversal amplitude.\n\nArguments\n\ntaumax::Real Initial peak bond stress τ_max (> 0).\ntaures::Real Residual bond stress τres (≥ 0, < τmax).\nspeak::Real Slip at initial peak stress (> 0).\nsres::Real Slip where the envelope reaches τ_res (> 0).\nalpha::Real=0.4 Exponent for the ascending branch (0 ≤ α ≤ 1).\nbeta::Real=1.0 Exponent for the descending branch (0 ≤ β ≤ 1).\nks::Real Shear stiffness (> 0) with constraint ks ≥ taumax/speak.\nkn::Real Normal stiffness (> 0).\np::Real Interface perimeter (> 0).\n\nBehavior\n\nCyclic effects: peak τ_max decays, speak shifts, and taures evolves with a measure of reversal amplitude and accumulated slip (handled via internal state).\nTangent shear stiffness equals the envelope derivative in inelastic updates, or ks when elastic.\n\nReturns\n\nA CyclicBondSlip object.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.DataTable","page":"Reference","title":"Serendip.DataTable","text":"DataTable(header, columns=Vector[]; name=\"\")\nDataTable(; pairs...)\nDataTable(header, matrix; name=\"\")\nDataTable(filename, delim='\\t')\n\nConstruct a tabular container with named columns.\n\nArguments\n\nheader::AbstractArray: column names (strings or symbols).\ncolumns::Vector{<:AbstractVector}: one vector per column. All columns must have the same length.\nname::AbstractString: optional table name.\npairs...: keyword form colName = vector. A special key name sets the table name.\nmatrix::AbstractMatrix: a 2D array whose columns become table columns.\nfilename::AbstractString: path to a delimited text file (.dat, .table, .json).\ndelim::Char: column delimiter when reading from file (default '\\t').\n\nExamples\n\nDataTable([\"x\",\"y\"], [[1,2,3], [10.0, 20.0, 30.0]]; name=\"XY\")\nDataTable(x=[1,2,3], y=[10.0,20.0,30.0], name=\"XY\")\nDataTable([\"a\",\"b\"], [1 2; 3 4; 5 6]; name=\"M\")\nDataTable(\"data.table\")                # reads header + data from file\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.Dof","page":"Reference","title":"Serendip.Dof","text":"Dof()\n\nCreates an object that represents a Degree of Freedom in a finite element analysis. Node objects include a field called dofs which is an array of Dof objects.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.DomainPlot","page":"Reference","title":"Serendip.DomainPlot","text":"DomainPlot(mesh; \n    size=(220,150), face_color=:aliceblue, warp=0.0,\n    edge_width=0.3, edge_color=:auto, outline_width=0.4,\n    line_elem_width=0.6,\n    field=\"\", limits=Float64[], field_kind=:auto, field_mult=1.0,\n    label=\"\", colormap=:coolwarm, diverging=false,\n    colorbar=:right, colorbar_ratio=0.9, bins=6,\n    font=\"NewComputerModern\", font_size=7.0,\n    interpolation=:linear,\n    azimuth=30, elevation=30, distance=0.0,\n    feature_edges=true, view_mode=:surface_with_edges,\n    light_vector=[0,0,0],\n    node_labels=false,\n    axes=:none, axis_labels=String[],\n    quiet=false)\n\nCreate a customizable domain plot for meshes and FE models.\n\nArguments\n\nmesh::Union{AbstractDomain,FEModel}: object to plot.\n\nKeywords\n\nsize::Tuple{Int,Int}: figure size in pt. (1 cm = 28.35 pt).\nface_color::Symbol: surface color for area/surface elements.\nwarp::Real: displacement scale factor for warped views.\nedge_width::Real: internal edge width for area/surface cells.\nedge_color::Union{Tuple,Symbol}: edge color; :auto darkens face color.\noutline_width::Real: boundary outline width.\nline_elem_width::Real: stroke width for line elements (bars/beams).\nfield::AbstractString: scalar field name for coloring; empty disables.\nlimits::Vector{<:Real}: field range [min,max]; empty vector enables auto range.\nfield_kind::Symbol: :auto | :none | :node | :element.\nfield_mult::Real: multiplier applied to field values.\nlabel::AbstractString: colorbar label.\ncolormap::Union{Symbol,Colormap}: e.g. :viridis, :coolwarm, or a Colormap.\ndiverging::Bool: center colormap at zero.\ncolorbar::Symbol: :none | :right | :bottom.\ncolorbar_ratio::Real: colorbar length scale (> 0).\nbins::Int: number of colorbar bins.\nfont::AbstractString: font family.\nfont_size::Real: font size (> 0).\ninterpolation::Symbol: :constant | :linear | :nonlinear surface shading.\nazimuth::Real: 3D azimuth angle in degrees.\nelevation::Real: 3D elevation angle in degrees.\ndistance::Real: camera distance (≥ 0).\nfeature_edges::Bool: enhance feature lines (:outline forces on).\nview_mode::Symbol: :surface_with_edges | :surface | :wireframe | :outline.\nlight_vector::Vector{<:Real}: light direction.\nnode_labels::Bool: show node ids.\naxes::Symbol: axes widget location (see _axes_widget_locations).\naxis_labels::Vector{<:AbstractString}: custom axis labels; defaults to [\"x\",\"y\",\"z\"].\nquiet::Bool: suppress constructor log.\n\nNotes\n\nUse save to export the figure to a file.\n\nExample\n\nplt = DomainPlot(model;\n                 field=\"ux\", field_kind=:node, warp=50.0,\n                 colormap=:viridis, colorbar=:right, label=\"uₓ [mm]\",\n                 view_mode=:surface_with_edges, feature_edges=true)\nsave(plt, \"model_plot.pdf\")\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.DruckerPrager","page":"Reference","title":"Serendip.DruckerPrager","text":"DruckerPrager(; E, nu=0.0, alpha=0.0, kappa=0.0, H=0.0, rho=0.0)\n\nLinear-elastic constitutive model with Drucker–Prager yield criterion and linear isotropic hardening. The model combines elastic response, pressure-dependent plastic yielding, and optional linear hardening.\n\nArguments\n\nE::Float64: Young’s modulus (must be > 0.0).\nnu::Float64: Poisson’s ratio (0.0 ≤ ν < 0.5).\nalpha::Float64: Drucker–Prager friction parameter (> 0.0).\nkappa::Float64: Drucker–Prager cohesion parameter (> 0.0).\nH::Float64: Hardening modulus (≥ 0.0). A value of 0.0 corresponds to perfect plasticity.\nrho::Float64: Constitutive density (≥ 0.0).\n\nState Variables\n\nStored internally in DruckerPragerState:\n\nσ::Vec6: Stress tensor (Mandel notation).\nε::Vec6: Strain tensor (Mandel notation).\nεpa::Float64: Accumulated plastic strain.\nΔλ::Float64: Plastic multiplier increment.\n\nNotes\n\nalpha and kappa define the Drucker–Prager yield surface.\nLinear isotropic hardening is controlled by H.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.DynamicAnalysis","page":"Reference","title":"Serendip.DynamicAnalysis","text":"DynamicAnalysis(model::FEModel; outdir=\"\", outkey=\"\")\n\nCreate a dynamic mechanical analysis for the given finite element model.\n\nArguments\n\nmodel::FEModel: Finite element model definition.\noutdir::String: Directory for output files. Defaults to \"./output\".\noutkey::String: Key prefix for output files. Defaults to \"out\".\n\nBehavior\n\nInitializes an AnalysisData instance with the given output settings.\nIf model.ctx.stress_state == :auto and model.ctx.ndim == 2, the stress state is set to :plane_strain.\nMarks the analysis as transient (this.data.transient = true).\n\nExample\n\nmodel = FEModel(mapper)\nanalysis = DynamicAnalysis(model; outdir=\"results\", outkey=\"run1\")\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.FEModel-Tuple{Mesh, RegionMapper}","page":"Reference","title":"Serendip.FEModel","text":"FEModel(mesh::Mesh, mapper::RegionMapper;\n        ndim::Int=0, stress_state::Symbol=:auto, thickness::Real=1.0, \n        g::Real=0.0, T0::Real=0.0, quiet::Bool=false)\n\nConstruct a finite element model from a Mesh and a RegionMapper.\n\nArguments\n\nmesh::Mesh: Discretized geometry containing nodes, elements, faces, and edges.\nmapper::RegionMapper: Provides mapping rules between geometric entities, element formulations, and constitutive models.\nndim::Int=0: Spatial dimension of the analysis (default uses mesh.ctx.ndim).\nstress_state::Symbol=:auto: Stress assumption (:plane_stress, :plane_strain, :axisymmetric, :auto).\nthickness::Real=1.0: Domain thickness for 2D analyses.\ng::Real=0.0: Gravity acceleration.\nT0::Real=0.0: Reference temperature.\nquiet::Bool=false: Suppress console output if true.\n\nReturns\n\nFEModel: Finite element model with nodes, elements, faces, edges, and context fully configured.\n\nNotes\n\nChecks compatibility between element formulations and constitutive models.\nInitializes nodes, elements, integration points, quadrature, and couplings.\nPrints model statistics unless quiet=true.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.GPath","page":"Reference","title":"Serendip.GPath","text":"GPath(path; embedded=false, shape=LIN3, tag=\"\", interface_tag=\"\", tip_tag=\"\", tips=:none)\n\nCreates a geometric path (GPath) entity, which represents a curve (typically a sequence of connected edges) embedded or placed in the geometry model. This structure is typically used to represent linear inclusions such as reinforcements, drains, etc. If embedded is false, interface elements will be created along the path. If tips is not :none, tip elements will be created at the endpoints of the path.\n\nArguments\n\npath::Path: The geometric path (sequence of edges and points) to be wrapped as a GPath.\nembedded::Bool=false: Whether this path should be embedded in the bulk mesh during meshing (e.g. cracks, reinforcements).\nshape::CellShape=LIN3: Shape function used for discretizing the path (e.g., quadratic line LIN3, cubic, etc.).\ntag::String=\"\": Optional label or name for this path (e.g. to identify or filter later).\ninterface_tag::String=\"\": Optional tag for use when interface elements are generated from the path.\ntips::Symbol=:none: Specify witch tips are considered (:start, :end, :both, :none) for the generation of tip interface elements.\ntip_tag::String=\"\": Optional tag for tip elements if tip elements are enabled.\n\nNote: Original OCC edges are removed from the geometry after constructing the path.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.GeoModel","page":"Reference","title":"Serendip.GeoModel","text":"GeoModel(; size=0.0, quiet = false)\n\nCreates a new geometry model (GeoModel) using Gmsh's OpenCASCADE (OCC) backend or blocks for structured meshing. This struct serves as a container for user-defined geometry entities and geometric paths (e.g., composed by line or arc definitions).\n\nArguments\n\nsize::Real=0.0: If greater than zero, sets the maximum element size for all entities in the model.\nquiet::Bool=false: If true, suppresses Gmsh initialization messages in the console.\n\nFields Initialized\n\nentities: A dictionary mapping Gmsh entity identifiers (dim, tag) to GeoEntity objects explicitly added by the user.\nblocks: A list of meshing Block structures used for meshing control or volume/surface definitions.\ngpaths: A list of GPath objects used to represent embedded geometric paths (e.g., for reinforcement, interfaces, or spring elements).\n\nExample\n\ngeo = GeoModel(size=0.5)       # set the maximum element size\ngeo = GeoModel(quiet=true)     # silent initialization\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.Ip","page":"Reference","title":"Serendip.Ip","text":"Ip(R, w)\n\nCreates an Ip object that represents an Integration Point in finite element analyses. R is a vector with the integration point local coordinates and w is the corresponding integration weight.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.LinearContact","page":"Reference","title":"Serendip.LinearContact","text":"LinearContact(; kn, ks)\n\nUnilateral linear elastic interface (contact) model.\n\nApplies a penalty-type relation between relative displacement and traction in compression and shear. In the normal direction, the response is linear elastic in compression but traction is zero in tension. The shear response is linear elastic according to ks.\n\nKeyword arguments\n\nkn::Float64 Normal stiffness (> 0).\nks::Float64 Shear stiffness (≥ 0).\n\nReturns\n\nA LinearContact constitutive object.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.LinearElastic","page":"Reference","title":"Serendip.LinearElastic","text":"LinearElastic(; E=1.0, nu=0.0)\n\nLinear elastic isotropic material model. This model can be used with bulk elements (e.g. solids), beams, bars, and shells. It assumes small deformations and linear stress-strain response.\n\nParameters\n\nE: Young's modulus. Must be positive.\nnu: Poisson's ratio. Must satisfy 0 ≤ ν < 0.5.\n\nThe shear correction factor alpha_s (defaulting to 5/6 for some formulations) is not a direct parameter of this constitutive model but is handled by the element formulations (e.g., MechBeam, MechShell) that use it.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.LinearInterface","page":"Reference","title":"Serendip.LinearInterface","text":"LinearInterface(; kn, ks)\n\nBilateral linear elastic interface model.\n\nApplies a penalty-type relation between relative displacement and traction in both normal and shear directions. The normal response is linear in both tension and compression; the shear response is linear elastic according to ks.\n\nKeyword arguments\n\nkn::Float64  Normal stiffness (> 0).\nks::Float64  Shear stiffness (≥ 0).\n\nReturns\n\nA LinearInterface constitutive object.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.LinearTip","page":"Reference","title":"Serendip.LinearTip","text":"LinearTip(; k)\n\nConstitutive model for a linear tip spring. Used to model the elastic response at the tips of bar or beam elements inside bulk material. Transmits tension and compression.\n\nArguments\n\nk::Real Stiffness (≥ 0). Reaction update: Δf = k·Δw.\n\nNotes\n\nw is the relative tip displacement along the element axis.\n\nReturns\n\nA LinearTip object.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.MechAnalysis","page":"Reference","title":"Serendip.MechAnalysis","text":"MechAnalysis(model::FEModel; outdir=\"\", outkey=\"\")\n\nCreate a static mechanical analysis for the given finite element model.\n\nArguments\n\nmodel::FEModel: Finite element model definition.\noutdir::String: Directory for output files. Defaults to \"./output\".\noutkey::String: Key prefix for output files. Defaults to \"out\".\n\nBehavior\n\nInitializes an AnalysisData instance with the given output settings.\nIf model.ctx.stress_state == :auto and model.ctx.ndim == 2, the stress state is set to :plane_strain.\n\nExample\n\nmodel = FEModel(mapper) # mapper is a RegionMapper with defined mappings\nanalysis = MechAnalysis(model; outdir=\"results\", outkey=\"job1\")\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.MechBar","page":"Reference","title":"Serendip.MechBar","text":"MechBar(; A)\n\nMechanical formulation for axial bar elements.\n\nThis formulation defines uniaxial axial behavior along the element length. It is typically used for truss or rod elements in 1D, 2D, or 3D analyses.\n\nParameters\n\nA::Float64: Cross-sectional area of the bar. Must be strictly positive.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.MechBondSlip","page":"Reference","title":"Serendip.MechBondSlip","text":"MechBondSlip(; p)\n\nCreate a mechanical line-interface formulation for bond–slip between a rebar and surrounding material.\n\nArguments\n\np::Real: rebar perimeter (length).\n\nBehavior\n\nPair with a bond–slip constitutive model.\n\nReturns\n\nA MechBondSlip object.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.Mesh","page":"Reference","title":"Serendip.Mesh","text":"Mesh(coordinates, connectivities, cellshapes=CellShape[]; tag=\"\", quiet=true) -> Mesh\n\nConstruct a Mesh object directly from nodal coordinates and element connectivities.\n\nArguments\n\ncoordinates::Matrix{<:Real}: Node coordinate matrix of size (nnodes, ndim).\nconnectivities::Vector{Vector{Int}}: Connectivity list, where each entry is a vector of node indices (1-based) defining an element.\ncellshapes::Vector{CellShape}=CellShape[]: Optional vector of element shapes (LIN2, QUAD4, etc.).   If not provided, shapes are inferred automatically from the number of nodes and spatial dimension.\ntag::String=\"\": Optional tag applied to all created elements.\nquiet::Bool=false: If true, suppresses console output during construction.\n\nReturns\n\nmesh::Mesh: A finite element mesh with nodes and elements created from the input data.\n\nExample\n\nusing Serendip\n\n# square domain with 4 points and 2 triangular elements\ncoordinates = [ 0.0 0.0;\n                1.0 0.0;\n                1.0 1.0;\n                0.0 1.0 ]\n\nconnectivities = [ [1, 2, 3], [1, 3, 4] ]\ncellshapes     = [ TRI3, TRI3 ]\n\nmesh = Mesh(coordinates, connectivities, cellshapes; tag=\"tri\")\nprintln(mesh)\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.Mesh-Tuple{GeoModel}","page":"Reference","title":"Serendip.Mesh","text":"Mesh(geo::GeoModel; ndim=0, recombine=false, quadratic=false, algorithm=:delaunay,\n     sort=true, quiet=false) -> Mesh\n\nGenerate a finite element mesh from a geometric model using Gmsh or structured blocks. Supports both unstructured meshing from OCC entities and structured meshing from geo.blocks. If both are present, unstructured meshing takes precedence.\n\nArguments\n\ngeo::GeoModel: Geometry model containing OCC entities and/or structured blocks.\nndim::Int=0: Target mesh dimension (1, 2, or 3). Defaults to the maximum dimension present in the geometry.\nrecombine::Bool=false: If true, recombines simplices (triangles, tetrahedra) into quads/hexas when possible.\nquadratic::Bool=false: If true, generates quadratic (second-order) elements.\nalgorithm::Symbol=:delaunay: Meshing algorithm:\n:delaunay → Delaunay (surface and 3D).\n:mesh_adapt → Adaptive meshing.\n:best → Frontal Delaunay (surface) + Delaunay (3D).\n:frontal → Frontal Delaunay (surface and 3D).\nsort::Bool=true: If true, reorder mesh entities (nodes, elements) consistently after generation.\nquiet::Bool=false: If true, suppress console messages.\n\nBehavior\n\nSets Gmsh meshing options according to algorithm and element order.\nDefines physical groups for all top-dimensional entities.\nHandles embedded points (p.embedded == true) by embedding them in host surfaces.\nRemoves orphan vertices without adjacencies.\nBuilds Node and Cell objects from Gmsh mesh data, including element connectivity.\nFor structured meshes uses block definitions from geo.\nIf geo.gpaths are present, generates insets and re-synchronizes.\n\nReturns\n\nmesh::Mesh: A mesh object containing nodes, elements, faces, edges, and context information.\n\nExample\n\ngeo = GeoModel()\n# ... build OCC surfaces/volumes or add blocks ...\nmesh = Mesh(geo; ndim=3, quadratic=true, algorithm=:frontal, sort=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.Mesh-Tuple{String}","page":"Reference","title":"Serendip.Mesh","text":"Mesh(filename::String; sort=false, quiet=true) -> Mesh\n\nLoad a finite element mesh from file. Supports VTK legacy (.vtk) and  VTK XML unstructured (.vtu) formats (preferred).\n\nArguments\n\nfilename::String: Path to the mesh file. Must have extension .vtk or .vtu.\nsort::Bool=false: If true, renumber nodes using a bandwidth-reduction algorithm after loading.\nquiet::Bool=true: If true, suppress console messages during loading.\n\nReturns\n\nmesh::Mesh: Mesh object containing nodes, elements, faces and edges.\n\nExample\n\nmesh = Mesh(\"model.vtu\"; sort=true, quiet=false)\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.MohrCoulombCohesive","page":"Reference","title":"Serendip.MohrCoulombCohesive","text":"MohrCoulombCohesive(; E, nu=0.0, ft, GF, wc, mu, psi=mu, ft_law=:hordijk, zeta=5.0)\n\nConstitutive model for cohesive elements with a Mohr–Coulomb strength criterion. The tensile branch is regularized with the bulk characteristic length h to ensure mesh-objective dissipation. Normal and shear interface stiffnesses are derived from E, nu, zeta, and h.\n\nKeyword arguments\n\nE::Real Young’s modulus of the bulk material (> 0).\nnu::Real Poisson’s ratio (0 ≤ ν < 0.5).\nft::Real Tensile strength (> 0).\nwc::Real Critical crack opening (> 0 if provided). May be computed from GF.\nGF::Real Mode-I fracture energy (> 0 if provided). May be used to compute wc.\nmu::Real Friction coefficient (> 0).\nψ::Real Dilarancy coefficient (> 0)\nft_law::Union{Symbol,AbstractSpline} = :hordijk Tensile softening law. Symbols: :linear, :bilinear, :hordijk; or a custom Spline.\nzeta::Real = 5.0 Dimensionless factor controlling elastic relative displacements (≥ 0).\n\nReturns\n\nA MohrCoulombCohesive object.\n\nNotes\n\nProvide either wc or GF. If only GF is given, wc is computed from ft_law.\nFrictional strength is governed by mu.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.MohrCoulombContact","page":"Reference","title":"Serendip.MohrCoulombContact","text":"MohrCoulombContact(; ft, wc, GF, mu, kn, ks, ft_law=:hordijk)\n\nConstitutive model for interface/contact elements with a Mohr–Coulomb strength criterion. It combines normal and shear stiffness, tensile strength, friction, and a post-peak tensile softening law defined either by the critical crack opening wc or by the fracture energy GF.\n\nKeyword arguments\n\nft::Real Tensile strength (≥ 0).\nmu::Real Friction coefficient (> 0).\nkn::Real Normal stiffness per unit area (> 0).\nks::Real Shear stiffness per unit area (> 0).\nwc::Real Critical crack opening (> 0 if provided). May be computed from GF.\nGF::Real Mode-I fracture energy (> 0 if provided). May be used to compute wc.\nft_law::Union{Symbol,AbstractSpline} = :hordijk Tensile softening law. Use a symbol :linear, :bilinear, or :hordijk, or pass a Spline.\n\nReturns\n\nAn MohrCoulombContact object.\n\nNotes\n\nProvide either wc or GF. If only GF is given, wc is computed based on ft_law.\nkn and ks control the elastic response before reaching the strength envelope.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.PowerExpBondSlip","page":"Reference","title":"Serendip.PowerExpBondSlip","text":"PowerExpBondSlip(; taumax, taures=0.0, speak, sc=20*speak, alpha=0.5, ks=taumax/speak, kn=100*ks)\n\nConstruct an exponential decay bond–slip material model.\n\nArguments\n\ntaumax: Peak bond stress τmax (must be positive).\ntaures=0.0: Residual bond stress τres (non-negative, ≤ τmax).\nspeak: Slip at which τmax is reached.\nsc=20*speak: Critical slip where softening branch tend to stabilize.\nalpha=0.5: Shape parameter controlling decay (must lie in (0,1)).\nks=taumax/speak: Tangential stiffness in slip direction (defaults to τmax/speak).\nkn=100*ks: Normal stiffness (defaults to 100·ks).\n\nReturns\n\nPowerExpBondSlip: A material instance representing the exponential decay bond–slip law.\n\nNotes\n\nChecks enforce positivity of parameters and ordering τmax ≥ τres.\nSuitable for bond–slip interface modeling with exponential decay to residual strength.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.PowerYieldCohesive","page":"Reference","title":"Serendip.PowerYieldCohesive","text":"PowerYieldCohesive(; E, nu=0.0, ft, fc, zeta=5.0, wc, GF, ft_law=:hordijk, alpha=1.5, gamma=0.1, theta=1.5)\n\nConstitutive model for cohesive elements with a power-lay yield surface ans ftlaw in tension.   The tensile ftlaw branch is regularized through a measure of the bulk element size h to ensure mesh-objective fracture energy dissipation.\n\nKeyword arguments\n\nE::Real:   Young’s modulus from the bulk material (must be > 0).\nnu::Real:   Poisson’s ratio (0 ≤ ν < 0.5).\nfc::Real:   Compressive strength (< 0).\nft::Real:  \nTensile strength (> 0).\nwc::Real:   Critical crack opening (must be > 0 if given). Can be specified alternatively to GF.\nmu::Real:   Friction coefficient (> 0).\nGF::Real:   Fracture energy (must be > 0 if given). Can be specified alternatively to wc.\nft_law::Union{Symbol,AbstractSpline} = :hordijk:   Softening law for post-peak tensile response. Options are: :linear, :bilinear, :hordijk, :soft or a custom function.\nalpha::Real = 1.5:   Parameter to control the shape of the yield surface (α > 0.5).\ngamma::Real = 0.1:   Parameter to control the residual shear strength (γ ≥ 0).\ntheta::Real = 1.5:   Parameter to control the rate of reduction of shear strength (θ ≥ 0).\nzeta::Real = 5.0:   Factor to control elastic relative displacements in cohesive formulations (≥ 0).\n\nReturns\n\nA PowerYieldCohesive object.\n\nNotes\n\nEither wc or GF must be provided. If only GF is given, wc is computed internally based on the chosen ft_law law.\nThe frictional contribution is governed by mu.\nNormal and shear stiffnesses (kn, ks) are computed from the mechanical properties of the bulk material and the characteristic length h of the adjacent bulk elements.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.RegionMapper","page":"Reference","title":"Serendip.RegionMapper","text":"RegionMapper()\n\nCreates an empty RegionMapper object.\n\nA RegionMapper holds a list of region mappings that associate parts of the mesh (defined by filters) with element formulations, constitutive models, and their parameters. Mappings can later be added using add_mapping.\n\nEach mapping associates a filtered region of the mesh with:\n\nAn element formulation (etype),\nA constitutive model (cmodel),\nA list of parameter values (params).\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.SolverSettings-Tuple{}","page":"Reference","title":"Serendip.SolverSettings","text":"SolverSettings(; tol=0.01, rtol=0.01, dT0=0.01, dTmin=1e-7, dTmax=0.1,\n                  rspan=0.01, tangent_scheme=:forward_euler, maxits=15, autoinc=false, quiet=false)\n\nDefines configuration parameters for controlling the analysis process.\n\nArguments\n\ntol::Float64: Absolute tolerance for convergence checks.\nrtol::Float64: Relative tolerance for convergence checks.\nautoinc::Bool: Enable automatic increment control .\ndT0::Float64: Initial increment of pseudo-time.\ndTmin::Float64: Minimum allowed increment of pseudo-time.\ndTmax::Float64: Maximum allowed increment of pseudo-time.\ntangent_scheme::Symbol: Tangent update approach (:forward_euler, :heun, :ralston, :backward_euler).\nmaxits::Int: Maximum number of iterations per increment .\nrspan::Float64: Progression span for reapplying the residual in nonlinear iterations.\nalpha::Float64: Damping coefficient for the mass matrix used in dynamic analyses.\nbeta::Float64: Damping coefficient for the stiffness matrix used in dynamic analyses.\nnmodes::Int: Number of modes to compute in modal analysis .\n\nExample\n\nsettings = SolverSettings(tol=1e-4, rtol=1e-3, autoinc=true)\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.UCP","page":"Reference","title":"Serendip.UCP","text":"UCP(; E, nu, fc, epsc, eta=4, ft, GF, wc, p0, alpha=0.666, beta=1.15, H=0.0)\n\nUnified Concrete Plasticity model.\n\nThis constitutive model defines a three-invariant plasticity surface for concrete, with a closed cap in compression and fracture-energy regularization in tension. It combines elastic isotropy, nonlinear hardening/softening in compression, and tension softening controlled by the fracture energy.\n\nKeyword arguments\n\nE::Real:   Young’s modulus (must be > 0).\nnu::Real:   Poisson’s ratio (0 ≤ ν < 0.5).\nfc::Real:   Uniaxial compressive strength (< 0).\nepsc::Real:   Strain at the compressive peak (< 0).\neta::Real = 2.2:   Shape parameter for the compression hardening/softening curve (eta > 1).\nft::Real:   Uniaxial tensile strength (> 0).\nGF::Real:   Tensile fracture energy (> 0). Can be given alternatively to wc.\nwc::Real:   Critical crack opening displacement (≥ 0). Can be given alternatively to GF.\np0::Real = NaN:   Elastic limit in isotropic compression. If not given, computed internally from fc and beta.\nalpha::Real = 0.666:   Shape parameter of the meridional section (0.2 < α ≤ 1.0).\nbeta::Real = 1.15:   Factor relating biaxial to uniaxial compressive strength (1 ≤ β ≤ 1.5).\nH::Real = 0.0:   Plastic modulus for isotropic compression (≥ 0).\n\nReturns\n\nA UCP material object that can be attached to mechanical bulk elements for 2D (plane strain) or 3D analyses. Not compatible with plane stress.\n\nNotes\n\nThe tensile law is regularized through GF and wc to ensure energy dissipation is independent of element size.\nThe compressive response follows a nonlinear curve defined by fc, epsc, and eta.\nThe cap position is adjusted by beta and p0.\nThe surface excentricity is computed internally to match the biaxial strength.\nThe surface section follows the Willam-Warnke ellipsoidal shape.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.VonMises","page":"Reference","title":"Serendip.VonMises","text":"VonMises(; E, nu=0.0, fy, H=0.0)\n\nLinear-elastic constitutive model with Von Mises yield criterion and linear isotropic hardening. Implements J2 (pressure-insensitive) plasticity with associated flow rule.\n\nArguments\n\nE::Float64: Young’s modulus (must be > 0.0).\nnu::Float64: Poisson’s ratio (0.0 ≤ ν < 0.5).\nfy::Float64: Initial yield stress (must be > 0.0).\nH::Float64: Hardening modulus (≥ 0.0). A value of 0.0 corresponds to perfect plasticity.\n\nState Variables\n\nStored in VonMisesState (and its variants for reduced kinematics):\n\nσ: Stress tensor (full Vec6 for 3D, reduced forms for plane stress, beam, and bar).\nε: Strain tensor (same format as σ).\nεpa::Float64: Accumulated plastic strain.\nΔλ::Float64: Plastic multiplier increment.\n\nVariants\n\nVonMisesState: 3D continuum elements (full stress/strain in Voigt notation).\nVonMisesPlaneStressState: Plane stress elements.\nVonMisesBeamState: Beam elements (axial + bending stress/strain).\nVonMisesBarState: Truss elements (uniaxial stress/strain).\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Serendip.WillamWarnke","page":"Reference","title":"Serendip.WillamWarnke","text":"WillamWarnke(; E, nu, fc, epsc, η=2.2, ft, GF=NaN, wc=NaN,\n              ft_law=:hordijk, fc_law=:popovics, beta=1.15)\n\nLinear‐elastic concrete with a Willam–Warnke yield surface and nonlinear hardening/softening in compression and tension softening regularized by fracture energy.\n\nKeyword arguments\n\nE::Real: Young’s modulus (> 0).\nnu::Real: Poisson’s ratio (0 ≤ ν < 0.5).\nfc::Real: Uniaxial compressive strength (< 0).\nepsc::Real: Strain at the compressive peak (< 0).\nη::Real=2.2: Shape parameter for the compressive curve (> 1).\nft::Real: Uniaxial tensile strength (> 0).\nGF::Real=NaN: Tensile fracture energy (> 0). Use GF or wc.\nwc::Real=NaN: Critical crack opening (≥ 0). Use wc or GF.\nft_law::Symbol=:hordijk: Tension softening law. :hordijk uses the Hordijk curve.\nfc_law::Symbol=:popovics: Compression law. :popovics uses a Popovics-type curve.\nbeta::Real=1.15: Biaxial/uniaxial compressive strength factor (1 ≤ β ≤ 1.5).\n\nExactly one of GF or wc must be provided.\n\nReturns\n\nA WillamWarnke material usable with 3D or plane-strain bulk elements. Not compatible with plane stress.\n\nNotes\n\nTension softening is regularized by GF or wc to keep energy dissipation mesh-objective.\nCompression response follows the selected fc_law shaped by (fc, epsc, η).\nbeta sets fb = β·fc internally.\n\nExample\n\nmat = WillamWarnke(E=30e9, nu=0.2, fc=-30e6, epsc=-0.002, ft=3e6,\n                   GF=120.0, ft_law=:hordijk, fc_law=:popovics, beta=1.15)\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#Base.copy-Tuple{GeoModel, Serendip.GeoEntity}","page":"Reference","title":"Base.copy","text":"Base.copy(geo, ent::GeoEntity)\n\nCopy a single geometric entity in the geometry model geo.\n\nReturns\n\nGeoEntity: The copied entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Base.copy-Tuple{GeoModel, Vector{<:Serendip.GeoEntity}}","page":"Reference","title":"Base.copy","text":"Base.copy(geo, ents::Vector{<:GeoEntity})\n\nCopy a list of geometric entities in the geometry model geo. Synchronizes OCC before and after copying.\n\nReturns\n\nVector{GeoEntity}: The copied entities.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Base.filter-Tuple{DataTable, Expr}","page":"Reference","title":"Base.filter","text":"filter(table::DataTable, expr::Expr)\n\nFilter rows of a DataTable object using a logical expression.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Base.intersect-Tuple{GeoModel, Any, Any}","page":"Reference","title":"Base.intersect","text":"intersect(geo, ents1, ents2; remove_object=true, tag=\"\")\n\nBoolean intersection of ents1 and ents2 in the geometric model geo.   All entities in each set must have the same topological dimension.\n\nArguments\n\ngeo::GeoModel: Geometry model where the operation occurs.\nents1: First set of entities (same dimension).\nents2: Second set of entities (same dimension).\nremove_object::Bool=true: If true, remove original inputs.\ntag::String=\"\": If non-empty, assigns this tag to all resulting entities.\n\nReturns\n\nVector: Resulting intersection entities.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Base.run-Tuple{Serendip.Analysis}","page":"Reference","title":"Base.run","text":"run(ana;\n    tol=0.01, rtol=0.01, autoinc=false,\n    dT0=0.01, dTmin=1e-7, dTmax=0.1, rspan=0.01,\n    tangent_scheme=:forward_euler, maxits=5,\n    alpha=0.0, beta=0.0, nmodes=5, rayleigh=false,\n    quiet=false)\n\nExecute a finite-element analysis and return the solver status.\n\nArguments\n\nana::Analysis: analysis object to solve.\n\nKeywords\n\ntol::Real: absolute convergence tolerance for the residual.\nrtol::Real: relative convergence tolerance for the residual.\nautoinc::Bool: enable automatic step size control.\ndT0::Real: initial time/load increment.\ndTmin::Real: minimum allowed increment.\ndTmax::Real: maximum allowed increment.\nrspan::Real: span parameter for the auto-increment controller.\ntangent_scheme::Symbol: global tangent computation approach (:forward_euler, :heun, :ralston).\nmaxits::Int: maximum nonlinear iterations per step.\nalpha::Float64: Mass matrix coefficient to compute damping in dynamic analyses.\nbeta::Float64: Stiffness matrix coefficient to compute damping in dynamic analyses.\nnmodes::Int: number of modes in modal analysis.\nrayleigh::Bool: enable Rayleigh damping.\nquiet::Bool: suppress console output.\n\nBehavior\n\nPrints a short banner with analysis type, stress model, scheme, and active threads unless quiet=true.\nBuilds SolverSettings from the provided keywords and advances stages via stage_iterator.\n\nReturns\n\nSolver status object returned by stage_iterator (implementation-specific).\n\nExample\n\nstatus = run(analysis;\n             tol=1e-3, rtol=1e-3, autoinc=true,\n             dT0=0.02, dTmin=1e-6, dTmax=0.1,\n             tangent_scheme=:rk2, maxits=10, alpha=0.0, beta=0.25,\n             nmodes=8, rayleigh=true)\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.RegionModel-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, Type{T}}} where {T<:Constitutive, S<:Serendip.ElementFormulation}","page":"Reference","title":"Serendip.RegionModel","text":"RegionModel(etype, cmodel; params...)\n\nCreates a RegionMapper for simple cases where the same element formulation and constitutive model are applied to the entire mesh.\n\nThis is a convenience shortcut equivalent to manually creating a RegionMapper and adding a mapping with selector=:all.\n\nArguments\n\netype::Type: The element formulation type (e.g., MechBulk).\ncmodel::Type: The constitutive model type (e.g., LinearElastic).\nparams...: Named parameters for the constitutive model.\n\nExample\n\nmodel = RegionModel(MechBulk, LinearElastic; rho=10, E=1.0, nu=0.3)\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_array-Tuple{GeoModel, GPath}","page":"Reference","title":"Serendip.add_array","text":"add_array(geometry, path; nx=1, ny=1, nz=1, dx=0.0, dy=0.0, dz=0.0)\n\nCreates a regular array of copies of a given GPath and adds them to the model.\n\nArguments\n\ngeometry::GeoModel: Target geometric model.\ngpath::GPath: The original path to replicate.\nnx, ny, nz: Number of copies in each spatial direction.\ndx, dy, dz: Spacing between copies in each direction.\n\nThe original path is keeped in the model as part of the array.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_bc-Tuple{Stage, Symbol, Any}","page":"Reference","title":"Serendip.add_bc","text":"add_bc(stage::Stage, kind::Symbol, selector; conds...)\n\nAdd a boundary condition (BC) to the given stage in the analysis.\n\nThis function attaches a boundary condition to a specific set of entities in the model, identified by kind and filtered using a spatial expression or coordinates.\n\nArguments\n\nstage::Stage: The analysis stage where the boundary condition will be applied.\nkind::Symbol: The type of boundary entity to apply the condition on. Options:\n:node – apply on nodes.\n:face – apply on faces (in 3D) or edges (in 2D).\n:edge – apply on edges explicitly.\nselector: A filtering expression or array of coordinates to select entities for the BC. If a coordinate array is provided for :node, it is converted into an equality selector.\nconds...: Named keyword arguments specifying the boundary conditions to apply (e.g., ux=0, uy=0, tz=-5).\n\nBehavior\n\nResolves the target entities (nodes, faces, or edges) in the finite element model using the provided selector.\nIf kind == :face in a 2D model, surface BCs are automatically mapped to edges with a notification.\nAdds the resulting BoundaryCondition to stage.bcs.\n\nReturns\n\nbc::BoundaryCondition: The created boundary condition object.\n\nExamples\n\nadd_bc(stage, :node, x==0, ux=0, uy=0)      # Fix displacement on nodes at x==0\nadd_bc(stage, :face, z==1, tz=-10)       # Apply surface traction at z==1\nadd_bc(stage, :edge, (y==0,z==1), qx=10)    # Apply linear traction at edges where y==0 && z==1\nadd_bc(stage, :node, [0.0, 0.0, 0.0], ux=0) # Constrain node at origin\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_block-Tuple{GeoModel, Any, Real, Real, Real}","page":"Reference","title":"Serendip.add_block","text":"add_block(geometry, X1, X2;\n    nx=0, ny=0, nz=0, n=0,\n    rx=1.0, ry=1.0, rz=1.0, r=0.0,\n    shape=nothing, tag=\"\")\n\nAdds a 1D, 2D or 3D block (Block) to the geometric model using two opposite corner points.\n\nArguments\n\ngeometry::GeoModel: Target geometric model to which the block is appended.\nX1::Vector{<:Real}: Coordinates of the first corner (lower vertex).\nX2::Vector{<:Real}: Coordinates of the opposite corner (upper vertex).\nnx::Int=1, ny::Int=0, nz::Int=0: Number of mesh divisions along x, y, and z.\nn::Int=0: Number of mesh divisions for 1D blocks (overrides nx).\nrx::Real=1.0, ry::Real=1.0, rz::Real=1.0: Element size grading ratios along x, y, and z.\nr::Real=0.0: Element size grading ratio for 1D blocks (overrides rx).\nshape: Optional finite element cell type (HEX8, HEX20, QUAD4, LIN2, etc.).   If omitted, it is inferred from the number of points and dimension.\ntag::String=\"\": Optional tag identifier for the block.\n\nBehavior\n\nThe block dimension (ndim) is inferred from the number of nonzero coordinate components:\n1D → line block (LIN2, LIN3)\n2D → surface block (QUAD4, QUAD8)\n3D → volume block (HEX8, HEX20)\nThe shape argument must match the inferred dimension.\n\nReturns\n\nBlock: The block object appended to geometry.blocks.\n\nExample\n\ngeo = GeoModel()\n\n# Define opposite corners of a 3D domain\nX1 = [0.0, 0.0, 0.0]\nX2 = [2.0, 1.0, 1.0]\n\n# Add a hexahedral block with graded mesh along z\nblk = add_block(geo, X1, X2;\nnx=8, ny=4, nz=4, rz=1.3,\nshape=HEX8,\ntag=\"foundation\")\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_boundary_contact_elements","page":"Reference","title":"Serendip.add_boundary_contact_elements","text":"add_boundary_contact_elements(mesh, selector; tag=\"\", nodes_tag=\"\", quiet=false)\n\nAdd contact interface elements to the boundary of mesh, coupling the original boundary faces with duplicated support nodes. Useful for modeling surface contact or elastic supports (e.g., Winkler foundation).\n\nIdempotency: This function generates the new contact elements first, then checks the existing mesh  to remove any old contact elements that match the Owner (Topology) and  Location (Geometry) of the new elements. This safely handles updates without  duplicating elements.\n\nArguments\n\nmesh::Mesh: The mesh where boundary contact elements will be added.\nselector: Region selector (e.g. \"bottom_face\").\ntag::String=\"\": Tag for generated contact elements.\nnodes_tag::String=\"\": Tag for the duplicated support nodes.\nquiet::Bool=false: Suppress output.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.add_boundary_shell_elements-Tuple{Mesh, Union{Expr, String, Tuple, Symbolic}}","page":"Reference","title":"Serendip.add_boundary_shell_elements","text":"add_boundary_shell_elements(mesh, selector; tag=\"\", contact_tag=\"\", quiet=false)\n\nAdd shell (surface) elements to the boundary of mesh, optionally coupling them with contact interface elements.\n\nIdempotency: This function generates the new boundary elements first, then checks the existing mesh  to remove any old shell/contact elements that match the Owner (Topology) and  Location (Geometry) of the new faces. This safely handles updates without  duplicating elements or accidentally deleting neighbors across a crack.\n\nArguments\n\nmesh::Mesh: The mesh where shell elements will be added.\nselector::Union{Expr,Symbolic,Tuple,String}: Region selector defining which boundary faces are converted to shells.\ntag::String=\"\": Tag assigned to the created shell elements.\ncontact_tag::String=\"\": If provided, also create contact elements linking original faces and new shell nodes, tagged with this value.\nquiet::Bool=false: Suppress console output if true.\n\nReturns\n\nMesh: The updated mesh including the new shell and, if applicable, contact elements.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_box-Tuple{GeoModel, Vector{<:Real}, Real, Real, Real}","page":"Reference","title":"Serendip.add_box","text":"add_box(geo, X, dx, dy, dz; tag=\"\")\n\nCreate a box volume in the geometric model geo, starting at corner X with dimensions dx, dy, and dz.\n\nArguments\n\ngeo::GeoModel: Geometry model where the box will be added.\nX::Vector{<:Real}: Corner coordinates [x, y, z].\ndx::Real: Box size along the x-direction.\ndy::Real: Box size along the y-direction.\ndz::Real: Box size along the z-direction.\ntag::String=\"\": Optional user-defined identifier for the volume.\n\nReturns\n\nVolume: The created box entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_circle-Tuple{GeoModel, Vector{<:Real}, Vector{<:Real}, Any}","page":"Reference","title":"Serendip.add_circle","text":"add_circle(geo, X, A, r; angle1=0.0, angle2=2π, tag=\"\")\n\nAdd a circular curve to the geometric model geo, centered at X with normal vector A and radius r.\n\nArguments\n\ngeo::GeoModel: Geometry model where the circle will be added.\nX::Vector{<:Real}: Center coordinates [x, y, z].\nA::Vector{<:Real}: Normal vector to the circle plane.\nr::Real: Circle radius.\nangle1::Real=0.0: Starting angle in radians.\nangle2::Real=2π: Ending angle in radians.\ntag::String=\"\": Optional user-defined identifier for the circle.\n\nReturns\n\nEdge: The created circle entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_circle_arc-Tuple{GeoModel, Point, Point, Point}","page":"Reference","title":"Serendip.add_circle_arc","text":"add_circle_arc(geo, p1, p2, p3; center=true, tag=\"\")\n\nAdd a circular arc to the geometric model geo, with points p1, p2, and p3.\n\nArguments\n\ngeo::GeoModel: Geometry model where the arc will be added.\np1::Point: Starting point of the arc.\np2::Point: Intermediate point or circle center, depending on center.\np3::Point: Ending point of the arc.\ncenter::Bool=true: If true, p2 is treated as the circle center; otherwise, it is a point on the arc.\ntag::String=\"\": Optional identifier for the arc.\n\nReturns\n\nEdge: The created arc entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_cohesive_elements","page":"Reference","title":"Serendip.add_cohesive_elements","text":"add_cohesive_elements(mesh, selector=nothing; tag=\"\", implicit=false, quiet=false)\n\nInsert cohesive elements into mesh by pairing coincident faces. Prevents insertion if the interface is already occupied by a contact element.\n\nAlgorithm:\n\nSplit elements into target (where interfaces are searched) and locked (kept as-is).\nOptionally duplicate target-cell nodes (implicit=false) to make interfaces topologically open.\nBuild a geometric index of existing contact interfaces to avoid overlap.\nPair coincident faces from target and neighboring locked boundaries.\nCreate cohesive elements with aligned node ordering across both faces.\nRemove old cohesive elements that match the same owners and interface geometry.\n\nArguments\n\nmesh::Mesh: Mesh to modify.\nselector::Union{Expr,Symbol,Symbolic,Tuple,String,Nothing}=nothing: Optional selector restricting where cohesive elements are created.\ntag::String=\"\": Tag assigned to generated cohesive elements.\nimplicit::Bool=false: If true, keeps the original shared topology (intrinsic/implicit interface activation). If false, duplicates target-region cell nodes before pairing faces so cohesive elements are created with distinct node sets on each side.\nquiet::Bool=false: Suppress output.\n\nReturns\n\nMesh: The updated mesh including the new cohesive elements.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.add_contact_elements-Tuple{Mesh, Vararg{Any}}","page":"Reference","title":"Serendip.add_contact_elements","text":"add_contact_elements(mesh, selectors...; tag=\"\", quiet=false)\n\nInserts contact elements along interfaces between distinct regions. Simplifies the removal of conflicting cohesive elements by performing a post-generation check.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_cylinder","page":"Reference","title":"Serendip.add_cylinder","text":"add_cylinder(geo, X, A, r; angle=2π, tag=\"\")\n\nCreate a cylindrical volume in the geometric model geo, with base center X, axis vector A, radius r, and optional angular span angle.\n\nArguments\n\ngeo::GeoModel: Geometry model where the cylinder will be added.\nX::Vector{<:Real}: Base center coordinates [x, y, z].\nA::Vector{<:Real}: Axis vector defining cylinder height and direction.\nr::Real: Cylinder radius.\nangle::Real=2π: Angular extent of the cylinder in radians.\ntag::String=\"\": Optional user-defined identifier for the volume.\n\nReturns\n\nVolume: The created cylindrical volume entity.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.add_disk","page":"Reference","title":"Serendip.add_disk","text":"add_disk(geo, X, A, r1, r2=0; tag=\"\")\n\nCreate a circular or elliptical surface in the geometric model geo, centered at X, oriented along the normal vector A, with radii r1 and r2.   If r2 == 0, a circular disk is created.\n\nArguments\n\ngeo::GeoModel: Geometry model where the disk will be added.\nX::Vector{<:Real}: Center coordinates [x, y, z].\nA::Vector{<:Real}: Normal vector defining the disk orientation.\nr1::Real: Major radius.\nr2::Real=0: Minor radius (defaults to r1 if zero).\ntag::String=\"\": Optional user-defined identifier for the surface.\n\nReturns\n\nSurface: The created disk entity.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.add_line","page":"Reference","title":"Serendip.add_line","text":"add_line(geo, p1, p2; tag=\"\")\n\nAdd a straight line connecting points p1 and p2 to the geometric model geo.\n\nArguments\n\ngeo::GeoModel: Geometry model where the line will be added.\np1::Point: Starting point of the line.\np2::Point: Ending point of the line.\ntag::String=\"\": Optional identifier for the line.\n\nReturns\n\nEdge: The created line entity.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.add_logger","page":"Reference","title":"Serendip.add_logger","text":"add_logger(ana::Analysis, kind::Symbol, selector::Any, filename::String = \"\")\n\nAdds a logger to an analysis, allowing you to record data during simulation.\n\nArguments\n\nana::Analysis:   The analysis object to which the logger will be attached. The logger is stored in ana.loggers.\nkind::Symbol:   Specifies the type of logger to create. Valid options are:\n:node: Logs data at a single node.\n:ip: Logs data at a single integration point.\n:nodegroup: Logs data for a group of nodes.\n:ipgroup: Logs data for a group of integration points.\n:nodalreduce: Logs aggregated data (e.g., sum or average) across selected nodes.\nselector::Any:   Defines how to select the items to log. Can be:\nA vector [x, y, z] specifying coordinates (the nearest matching item will be used if no exact match is found).\nA logical expression (e.g., x > 0).\nA predefined tag or list of items.\nfilename::String (optional):   Name of the file where the log will be saved. If not provided, the logger will use the default output directory in ana.data.outdir.   The file extension should be .table, .table or .json.\n\nReturns\n\nA Logger object of type Logger{Node} or Logger{Ip} depending on kind. This logger is also pushed into ana.loggers.\n\nNotes\n\nIf kind is :node or :ip and the selector matches multiple items, only the first match will be logged.\nFor :nodegroup and :ipgroup, the selected items are automatically sorted based on coordinates.\nIf no items match the selector, a notification is displayed.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.add_loop-Tuple{GeoModel, Vector{Edge}}","page":"Reference","title":"Serendip.add_loop","text":"add_loop(geo, edges)\n\nCreate a closed curve loop from the sequence of edges. Used to define surface boundaries.\n\nArguments\n\ngeo::GeoModel: Geometry model where the loop will be added.\nedges::Vector{Edge}: Ordered list of edges forming a closed loop.\n\nReturns\n\nLoop: The created curve loop entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_mapping-Union{Tuple{S}, Tuple{T}, Tuple{RegionMapper, Any, Type{S}, Type{T}}} where {T<:Constitutive, S<:Serendip.ElementFormulation}","page":"Reference","title":"Serendip.add_mapping","text":"add_mapping(mapper::RegionMapper, selector, etype, cmodel; params...)\n\nAdds a new region mapping to the given RegionMapper.\n\nEach mapping associates a filtered region of the mesh with:\n\nAn element formulation (etype),\nA constitutive model (cmodel),\nA list of parameter values (params).\n\nArguments\n\nmapper::RegionMapper: The mapper to add the region mapping to.\nselector: A filtering expression defining the mesh region (e.g., x==0, :all).\netype::Type: The element formulation type (e.g., MechBulk).\ncmodel::Type: The constitutive model type (e.g., LinearElastic).\nparams...: Named parameters for the constitutive model (e.g., rho=10.0, E=30.0e6).\n\nExample\n\nadd_mapping(mapper, x>=0, MechBulk, LinearElastic; rho=10.0, E=30.0e6, nu=0.3)\n\nTrows\n\nAn error if a mapping with the same selector already exists in the mapper.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_monitor","page":"Reference","title":"Serendip.add_monitor","text":"add_monitor(\n    ana::Analysis,\n    kind::Symbol,\n    selector::Any,\n    expr::Union{Symbol, Expr, Tuple, Array},\n    filename::String = \"\";\n    stop::Union{Expr,Tuple,Array,Nothing} = nothing\n)\n\nAdds a monitor to the analysis for observing quantities during the simulation. Monitors are used to evaluate expressions at selected nodes or integration points and optionally trigger stopping conditions.\n\nPositional Arguments\n\nana::Analysis:   The analysis object to which the monitor will be attached. The monitor is stored in ana.monitors.\nkind::Symbol:   Specifies the type of monitor. Valid options are:\n:node: Monitor a single node.\n:ip: Monitor a single integration point.\n:nodegroup: Monitor a group of nodes.\n:ipgroup: Monitor a group of integration points.\n:nodalreduce: Monitor reduced quantities across selected nodes.\nselector:   Defines how to select the items to monitor. Can be:\nA vector [x, y, z] specifying coordinates (the nearest matching item will be used if no exact match is found).\nA logical expression (e.g., x > 0 && y < 1).\nA predefined tag or list of items.\nexpr:   One or more expressions to monitor. Can be a single Symbol (e.g., :ux), or a collection (e.g., [:ux, :uy], a tuple, or an array).\nfilename::String (optional):   Name of the file where the monitor results will be saved. If a path is not   provided, the file is saved in the current directory.   The file extension should be .table, .table or .json.\n\nKeyword Arguments\n\nstop (optional):   Defines stop conditions for the monitor. Can be:\nAn condition (e.g., :(ux > 0.1)).\nA collection of conditions.\nNote: Stop conditions are only supported for :node and :ip kinds.\n\nReturns\n\nA Monitor object of type Monitor{Node} or Monitor{Ip}, depending on kind. The monitor is also pushed into ana.monitors.\n\nNotes\n\nIf kind is :node or :ip and the selector matches multiple items, only the first match will be monitored.\nFor :nodegroup and :ipgroup, the selected items are sorted automatically by coordinate sum.\nIf no items match the selector, the nearest item is chosen and a notification is displayed.\n\nExample\n\n# Monitor displacement ux at a node at x=0 and y==0\nadd_monitor(ana, :node, (x==0,y==0), :ux, \"monitor_node_ux.dat\")\n\n# Monitor stress components at a group of integration points\nadd_monitor(ana, :ipgroup, z>1.0, [:sxx, :syy], \"stress_ipgroup.dat\")\n\n# Monitor a node and stop analysis if ux > 0.01 at that node\nadd_monitor(ana, :node, [0.0, 0.0, 0.0], :ux; stop=:(ux > 0.01))\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.add_path-Tuple{GeoModel, Vector{Edge}}","page":"Reference","title":"Serendip.add_path","text":"add_path(geometry, edges; embedded=false, shape=LIN3, tag=\"\", interface_tag=\"\", tip_tag=\"\", tips=:none)\n\nAdds a logical path structure (GPath) to the geometric model from a sequence of connected Edge objects. This is useful for modeling discrete and embedded 1D elements such as reinforcement bars, drains, or inclusions.\n\nArguments\n\ngeometry::GeoModel: Target geometric model.\nedges::Vector{Edge}: Sequence of connected edges that define the path.\nembedded::Bool=false: Whether the path is embedded into a solid domain. If embedded is false, interface elements will be created.\nshape::CellShape=LIN3: Finite element shape for discretization of the path (LIN2 or LIN3).\ntag::String=\"\": Identifier tag for the path.\ninterface_tag::String=\"\": Optional tag used for interface elements.\ntip_tag::String=\"\": Optional tag for used for tip elements at endpoints.\ntips::Symbol=:none: Specifies which endpoint elements are generated (e.g., :start, :end, :both). If tips is :none, no tips elements are created.\n\nReturns\n\nGPath: The path structure added to the model.\n\nNote: Original OCC edges are removed from the geometry after constructing the path.\n\nExample\n\ngeo = GeoModel()\npoint1 = add_point(geo, [0,0,0])\npoint2 = add_point(geo, [1,0,0])\npoint3 = add_point(geo, [2,0,0])\nedge1 = add_line(geo, p1, p2)\nedge2 = add_line(geo, p2, p3)\n\npath = add_path(geo, [edge1, edge2]; tag=\"reinforcement\", interface_tag=\"contact\")\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_plane_surface-Tuple{GeoModel, Vararg{Serendip.Loop}}","page":"Reference","title":"Serendip.add_plane_surface","text":"add_plane_surface(geo, loops...; tag=\"\")\n\nCreate a planar surface in the geometric model geo, bounded by one or more loops.\n\nArguments\n\ngeo::GeoModel: Geometry model where the surface will be added.\nloops::Loop...: One outer loop and optionally inner loops (holes).\ntag::String=\"\": Optional identifier for the surface.\n\nReturns\n\nSurface: The created surface entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_polygon-Tuple{Any, Vector{Point}}","page":"Reference","title":"Serendip.add_polygon","text":"add_polygon(geo, points; tag=\"\")\n\nCreate a planar polygonal surface in the geometric model geo from an ordered list of points.\n\nArguments\n\ngeo::GeoModel: Geometry model where the polygon will be added.\npoints::Vector{Point}: Ordered vertices of the polygon. Edges are created sequentially and closed automatically.\ntag::String=\"\": Optional user-defined identifier for the surface.\n\nReturns\n\nSurface: The created polygonal surface entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_rectangle-Tuple{GeoModel, Vector{<:Real}, Real, Real}","page":"Reference","title":"Serendip.add_rectangle","text":"add_rectangle(geo, X, dx, dy; tag=\"\")\n\nCreate a rectangular planar surface in the geometric model geo, starting at corner X with dimensions dx and dy.\n\nArguments\n\ngeo::GeoModel: Geometry model where the rectangle will be added.\nX::Vector{<:Real}: Corner coordinates [x, y, z].\ndx::Real: Rectangle width along the x-direction.\ndy::Real: Rectangle height along the y-direction.\ntag::String=\"\": Optional user-defined identifier for the surface.\n\nReturns\n\nSurface: The created rectangular surface entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_series-Tuple{Chart, Symbol, AbstractArray, AbstractArray}","page":"Reference","title":"Serendip.add_series","text":"add_series(chart::Chart, kind::Symbol, X::AbstractArray, Y::AbstractArray; kwargs...)\nadd_series(chart::Chart, X::AbstractArray, Y::AbstractArray; kwargs...)\n\nAppend a DataSeries to chart. The second version uses kind = :line.\n\nArguments\n\nchart::Chart : Target chart (mutated).\nkind::Symbol : Plot type: :line, :scatter, :bar.\nX, Y::AbstractArray : Data vectors.\n\nKeyword options\n\nline_style::Symbol = :solid : Line style (e.g. :solid, :dash, ...).\ndash::Vector{Float64} = Float64[] : Custom dash pattern. If nonempty, overrides line_style.\ncolor = :default : Line/marker color. :default selects from the chart palette cyclically.\nline_width::Float64 = 0.5 : Line width (> 0).\nmark::Symbol = :none : Mark shape.\nmark_size::Float64 = 2.5 : Mark size (> 0).\nmark_color = :white : Mark fill color.\nmark_stroke_color = :default : Mark edge color (:default follows color).\nlabel::AbstractString = \"\" : Legend label.\ntag::AbstractString = \"\" : On-curve annotation text.\ntag_location::Symbol = :top : Relative location of tag (:top, :bottom, :left, :right).\ntag_position::Float64 = 0.5 : Position along the curve in [0,1].\ntag_alignment::Symbol = :horizontal : Tag orientation (:horizontal, :vertical, :parallel).\nbar_width::Float64 = 0.0 : Bar width in x-data units (0 enables auto width).\nbar_base::Float64 = 0.0 : Bar baseline in y-data units.\norder::Int = 0 : Z-order. If 0, an incremental order is assigned.\n\nReturns\n\nThe series object.\n\nExamples\n\nch = Chart(size=(300,200), xlabel=\"Time [s]\", ylabel=\"Displacement [mm]\",\n           xlimits=[0.0,10.0], ylimits=[-5.0,5.0], legend=:bottom_right)\n\nadd_line(ch, 0:0.1:10, sin.(0:0.1:10); label=\"sin\")\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_sphere-Tuple{GeoModel, Vector{<:Real}, Real}","page":"Reference","title":"Serendip.add_sphere","text":"add_sphere(geo, X, r; tag=\"\")\n\nCreate a spherical volume in the geometric model geo, centered at X with radius r.\n\nArguments\n\ngeo::GeoModel: Geometry model where the sphere will be added.\nX::Vector{<:Real}: Sphere center coordinates [x, y, z].\nr::Real: Sphere radius.\ntag::String=\"\": Optional user-defined identifier for the volume.\n\nReturns\n\nVolume: The created spherical volume entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_stage-Tuple{Serendip.Analysis}","page":"Reference","title":"Serendip.add_stage","text":"add_stage(ana::Analysis; name=\"\", nincs=1, nouts=0, tspan=0.0, activate=:all, deactivate=:none)\n\nAppend a new numerical analysis stage to the AnalysisData container.\n\nA stage defines a phase of the simulation with specific load increments, output frequencies,  and topological changes (activating or deactivating elements).\n\nArguments\n\nana::Analysis: The parent analysis object containing the model and data.\n\nKeywords\n\nname::String: User-defined label for the stage (default = \"\").\nnincs::Int: Number of increments to reach the end of the stage (default = 1).\nnouts::Int: Number of output steps during the stage (default = 0).\ntspan::Float64: Physical time span for transient analysis (default = 0.0).\nactivate::Any: Selector or filter to enable specific elements at the start of the stage (default = :all).\ndeactivate::Any: Selector or filter to disable specific elements at the start of the stage (default = :all).\n\nReturns\n\nStage: The newly created and initialized stage object.\n\nNotes\n\nThe function automatically assigns a stage ID based on the current number of stages in ana.data.stages.\nElements are selected via the select function using the provided activate and deactivate filters.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_surface_filling-Tuple{GeoModel, Serendip.Loop}","page":"Reference","title":"Serendip.add_surface_filling","text":"add_surface_filling(geo, loop; tag=\"\")\n\nCreate a filled surface bounded by the closed loop. Useful for non-planar or curved boundaries.\n\nArguments\n\ngeo::GeoModel: Geometry model where the surface will be added.\nloop::Loop: Boundary curve loop defining the surface perimeter.\ntag::String=\"\": Optional user-defined identifier for the surface.\n\nReturns\n\nSurface: The created filled surface entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_surface_loop-Tuple{Vector{Surface}}","page":"Reference","title":"Serendip.add_surface_loop","text":"add_surface_loop(surfaces)\n\nCreate a surface loop from a collection of surfaces. Used to define closed regions for volume creation.\n\nArguments\n\nsurfaces::Vector{Surface}: List of surfaces forming a closed shell.\n\nReturns\n\nSurfaceLoop: The created surface loop entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.add_volume-Tuple{GeoModel, Vector{Serendip.SurfaceLoop}}","page":"Reference","title":"Serendip.add_volume","text":"add_volume(geo, sloops; tag=\"\")\n\nCreate a 3D volume in the geometric model geo, bounded by the given surface loops sloops.\n\nArguments\n\ngeo::GeoModel: Geometry model where the volume will be added.\nsloops::Vector{SurfaceLoop}: List of closed surface loops defining the volume boundary.\ntag::String=\"\": Optional user-defined identifier for the volume.\n\nReturns\n\nVolume: The created volume entity.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.array-Tuple{Block}","page":"Reference","title":"Serendip.array","text":"array(block::Block; nx=1, ny=1, nz=1, dx=0.0, dy=0.0, dz=0.0)\n\nCreates a rectangular array of blocks of size nx×ny×nz using copies of block spaced at dx, dy and dz. The original bĺock is considered as part of the result.\n\nExamples\n\njulia> block = Block([ 0 0; 1 1 ], nx=3, ny=3);\n\njulia> blocks = array(block, nx=2, ny=2, dx=1, dy=1);\n\njulia> length(blocks)\n4\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.cut!","page":"Reference","title":"Serendip.cut!","text":"cut!(table::DataTable, field, value=0.0; after=false)\n\nCut a DataTable object at a given value of a field. If after is true, the DataTable is cut after the given value.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.cut-Tuple{GeoModel, Any, Any}","page":"Reference","title":"Serendip.cut","text":"cut(geo, ents1, ents2; remove_object=false, remove_tool=true, tag=\"\")\n\nBoolean cut of ents1 by ents2 in the geometric model geo.   All entities in each set must have the same topological dimension.\n\nArguments\n\ngeo::GeoModel: Geometry model where the operation occurs.\nents1: Objects to be cut (all same dimension).\nents2: Tools that cut ents1 (all same dimension as ents1).\nremove_object::Bool=false: If true, remove original objects.\nremove_tool::Bool=true: If true, remove tool entities.\ntag::String=\"\": If non-empty, assigns this tag to all resulting entities.\n\nReturns\n\nVector: Resulting entities from the cut.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.evaluate","page":"Reference","title":"Serendip.evaluate","text":"evaluate(expr, vars...)\n\nReturns the result of the arithmetic expression expr using values defined in vars if necessary.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.extrude-Tuple{Block}","page":"Reference","title":"Serendip.extrude","text":"EXTRUDE\n\nGets a 3D Block by extruding a 2D block in the direction given by axis and a distance length. It also sets the number of divisions n in the extruded direction.\n\nExamples\n\njulia> block2d = Block([ 0 0; 1 1 ], nx=3, ny=4, shape=QUAD8);\njulia> block3d = extrude(block2d, axis=[0,0,1], length=1, n=5)\nBlock\n  nodes: 8-element Vector{Node}:\n    1: Node  id=1\n    2: Node  id=2\n    3: Node  id=3\n    4: Node  id=4\n    5: Node  id=5\n    6: Node  id=6\n    7: Node  id=7\n    8: Node  id=8\n  shape: CellShape  name=\"HEX8\"\n  cellshape: CellShape  name=\"HEX20\"\n  nx: 3\n  ny: 4\n  nz: 5\n  rx: 1.0\n  ry: 1.0\n  rz: 1.0\n  tag: \"\"\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.extrude-Tuple{GeoModel, Any, Any}","page":"Reference","title":"Serendip.extrude","text":"extrude(geo, ents, A; num_elements=[], heights=[], recombine=false)\n\nExtrude one or more entities ents in the geometric model geo along vector A.\n\nArguments\n\ngeo::GeoModel: Geometry model containing the source entities.\nents: A single entity or a vector of entities to extrude.\nA::AbstractVector{<:Real}: Extrusion vector [dx, dy, dz].\nnum_elements::Vector{Int}=[]: Optional layer counts per step for transfinite extrusion.\nheights::Vector{<:Real}=[]: Optional layer heights per step. Must match num_elements if provided.\nrecombine::Bool=false: If true, recombine into quads/hexas where possible.\n\nReturns\n\nVector: Newly created entities resulting from the extrusion.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.extrude-Tuple{Mesh}","page":"Reference","title":"Serendip.extrude","text":"extrude(mesh; length=1.0, n=1, axis=nothing, quiet=true, lagrangian=false)\n\nGenerates a 3D mesh by extruding a planar mesh using a direction axis, a length and a number of divisions n.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.fillet","page":"Reference","title":"Serendip.fillet","text":"fillet(geo, volumes, curves, radii; remove_volume=true)\n\nApply edge fillets of given radii to curves on volumes in the geometric model geo.\n\nArguments\n\ngeo::GeoModel: Geometry model where the operation occurs.\nvolumes: A volume or vector of volumes to modify.\ncurves: A curve or vector of curves to fillet.\nradii: A radius or vector of radii corresponding to curves.\nremove_volume::Bool=true: If true, remove original volumes.\n\nReturns\n\nVector: Resulting modified entities after filleting.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.fragment-Tuple{GeoModel, Any, Any}","page":"Reference","title":"Serendip.fragment","text":"fragment(geo, ents1, ents2; remove_object=true, remove_tool=true, tag=\"\")\n\nMutually fragment ents1 and ents2 in the geometric model geo, splitting them at intersections.\n\nArguments\n\ngeo::GeoModel: Geometry model where the operation occurs.\nents1: First set of entities.\nents2: Second set of entities.\nremove_object::Bool=true: If true, remove original objects.\nremove_tool::Bool=true: If true, remove tool entities.\ntag::String=\"\": If non-empty, assigns this tag to all resulting entities.\n\nReturns\n\nVector: All resulting fragmented entities.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.fuse-Tuple{GeoModel, Any, Any}","page":"Reference","title":"Serendip.fuse","text":"fuse(geo, ents1, ents2; remove_object=true, remove_tool=true, tag=\"\")\n\nBoolean union of ents1 and ents2 in the geometric model geo.   All entities in each set must have the same topological dimension.\n\nArguments\n\ngeo::GeoModel: Geometry model where the operation occurs.\nents1: First set of entities (same dimension).\nents2: Second set of entities (same dimension).\nremove_object::Bool=true: If true, remove original objects.\nremove_tool::Bool=true: If true, remove tool entities.\ntag::String=\"\": If non-empty, assigns this tag to all resulting entities.\n\nReturns\n\nVector: Resulting fused entities.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.get_values-Tuple{Element}","page":"Reference","title":"Serendip.get_values","text":"get_values(elem::Element)\n\nReturns a DataTable containing state variable values at all integration points of the given element.\n\nArguments\n\nelem::Element: The element whose integration point values are to be retrieved.\n\nReturns\n\nDataTable: A table with one row per integration point and columns for each state variable.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.laplacian_smooth!-Tuple{Mesh}","page":"Reference","title":"Serendip.laplacian_smooth!","text":"laplacian_smooth!(mesh; maxit, verbose, mintol, tol, savesteps, savedata, filekey, smart, weighted)\n\nSmooths a finite element mesh using Laplacian smoothing (standard, weighted, smart).\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.mirror-NTuple{5, Any}","page":"Reference","title":"Serendip.mirror","text":"mirror(ents, a, b, c, d)\n\nMirror one or more entities ents with respect to the plane a*x + b*y + c*z + d = 0.\n\nArguments\n\nents: A single entity or a vector of entities to mirror.\na::Real: Plane coefficient for x.\nb::Real: Plane coefficient for y.\nc::Real: Plane coefficient for z.\nd::Real: Plane offset.\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.mirror-Tuple{Block}","page":"Reference","title":"Serendip.mirror","text":"mirror\n\nCreates a new Block by mirroring block according to a plane defined by a normal axis and base point.\n\nExamples\n\njulia> block1 = Block([ 0 0; 2 1; 1 1; 0 1], nx=2, ny=2);\njulia> block2 = mirror(block1, axis=[1,1], base=[2,1])\nBlock\n  nodes: 4-element Vector{Node}:\n    1: Node  id=1\n    2: Node  id=2\n    3: Node  id=3\n    4: Node  id=4\n  shape: CellShape  name=\"QUAD4\"\n  cellshape: CellShape  name=\"QUAD4\"\n  nx: 2\n  ny: 2\n  nz: 1\n  rx: 1.0\n  ry: 1.0\n  rz: 1.0\n  tag: \"\"\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.move-Tuple{Block}","page":"Reference","title":"Serendip.move","text":"move\n\nMoves a block position by updating its coordinates according to dx, dy and dz.\n\nExamples\n\njulia> block = Block([ 0 0 0; 1 1 1], nx=1, ny=2, nz=3)\n\njulia> move(block, dx=0.5, dy=1.0)\n\njulia> block\nBlock\n    nodes: 8-element Vector{Node}:\n        1: Node  id=1\n        2: Node  id=2\n        3: Node  id=3\n        4: Node  id=4\n        5: Node  id=5\n        6: Node  id=6\n        7: Node  id=7\n        8: Node  id=8\n    shape: CellShape  name=\"HEX8\"\n    cellshape: CellShape  name=\"HEX8\"\n    nx: 1\n    ny: 2\n    nz: 3\n    rx: 1.0\n    ry: 1.0\n    rz: 1.0\n    tag: \"\"\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.move-Tuple{Mesh}","page":"Reference","title":"Serendip.move","text":"move(mesh, [dx=0.0,] [dy=0.0,] [dz=0.0])\n\nMoves a Mesh object mesh. Also returns a reference.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.permute_coordinates-Tuple{Mesh, String}","page":"Reference","title":"Serendip.permute_coordinates","text":"permute_coordinates(mesh, order)\n\nChanges the coordinate axes of a mesh according to a new order given as a string.\n\nExample\n\n    mesh = Mesh(Block([0 0; 1 1], nx=2, ny=2));\n    permute_coordinates(mesh, \"zxy\")\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.polar-Tuple{AbstractArray}","page":"Reference","title":"Serendip.polar","text":"polar\n\nCreates a `polar` array from `blocks` by rotating it\naround `axis` along an `angle` domain. `n` representes\nthe number of cells in the polar direction.\nThe elements in `blocks` can be `Block` objects or even lists of\n`Block` objects.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.polar-Tuple{Block}","page":"Reference","title":"Serendip.polar","text":"polar\n\nCreates a `polar` array using copies of `block` by rotating it\naround `axis` along an `angle` domain. `n` representes\nthe number of cells in the polar direction.\n\n# Examples\n\n```julia\njulia> block = Block([ 0 0; 1 0; 0.707 0.707; 0 1; 0.5 0; 0.924 0.383; 0.382 0.924; 0.354 0.354 ], nx=3, ny=3);\n\njulia> blocks = polar(block, base=[ 0, 0 ,0 ], axis=[ 0, 0, 1 ], angle=360, n=4);\n\njulia> length(blocks)\n4\n```\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.rand_mesh-Tuple{Vararg{Int64}}","page":"Reference","title":"Serendip.rand_mesh","text":"rand_mesh(n...; shape=nothing)\n\nGenerate a random structured mesh of unit size in 2D or 3D.\n\nArguments\n\nn::Int...: Number of elements in each spatial direction.  \nFor 2D: (nx, ny)  \nFor 3D: (nx, ny, nz)\nshape: Optional element type.   If not provided, a random element shape is chosen among   (TRI3, TRI6, QUAD4, QUAD8) for 2D, or   (TET4, TET10, HEX8, HEX20) for 3D.\n\nReturns\n\nMesh: A randomly generated finite element mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.resize","page":"Reference","title":"Serendip.resize","text":"resize(table::DataTable, n::Int=0; ratio=1.0)\n\nResize a DataTable object to `n` rows. If `n` is not provided, the number of rows is calculated using `ratio` parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.revolve","page":"Reference","title":"Serendip.revolve","text":"revolve(geo, ents, X, A, angle; num_elements=[], heights=[], recombine=false)\n\nRevolve one or more entities ents in the geometric model geo by angle radians around the axis defined by point X and direction A.\n\nArguments\n\ngeo::GeoModel: Geometry model containing the source entities.\nents: A single entity or a vector of entities to revolve.\nX::AbstractVector{<:Real}: Point on the rotation axis [x, y, z].\nA::AbstractVector{<:Real}: Axis direction vector [ax, ay, az].\nangle::Real: Sweep angle in radians.\nnum_elements::Vector{Int}=[]: Optional layer counts per step.\nheights::Vector{<:Real}=[]: Optional layer heights per step.\nrecombine::Bool=false: If true, recombine into quads/hexas where possible.\n\nReturns\n\nVector: Newly created entities resulting from the revolution.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Serendip.revolve-Tuple{Mesh}","page":"Reference","title":"Serendip.revolve","text":"revolve(mesh; base=[0,0,0], axis=[0,0,1], minangle=0, maxangle=360, angle=360, n=8, collapse=true, lagrangian=false)\n\nGenerates a 3D mesh by revolving a 1D o3 2D mesh using a base point, an axis, a rotation angle and a number of divisions n. If collapse is true, each element with concident nodes is collapsed into simpler element with fewer nodes. If lagrangian is true, lagrangian elements are generated when posible.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.revolve-Tuple{Node}","page":"Reference","title":"Serendip.revolve","text":"revolve(node; base=[0,0,0], axis=[0,0,1], minangle=0, maxangle=360, angle=360, n=8)\n\nGenerates a mesh composed by LIN3 elements by revolving a node using a base point, an axis, a rotation angle and a number of divisions n.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.rotate-Tuple{Block}","page":"Reference","title":"Serendip.rotate","text":"rotate!\n\nRotates block an angle (default 90 degrees) around an axis that passes by a base point.\n\nExamples\n\njulia> block = Block([ 0 0; 1 1 ], nx=2, ny=2);\n\njulia> get_coords(block)\n4×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 1.0  0.0  0.0\n 1.0  1.0  0.0\n 0.0  1.0  0.0\n\njulia> rotate(block, base=[ 0, 0, 0 ], axis=[ 0, 0, 1], angle=45);\n\njulia> get_coords(block)\n4×3 Matrix{Float64}:\n 0.0       0.0       0.0\n 0.707107  0.707107  0.0\n 0.0       1.41421   0.0\n 0.0       0.707107  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.rotate-Tuple{GeoModel, Vararg{Any, 4}}","page":"Reference","title":"Serendip.rotate","text":"rotate(geo, ents, X, A, angle)\n\nRotate one or more entities ents in the geometric model geo by angle radians around the axis defined by point X and direction A.\n\nArguments\n\ngeo::GeoModel: Geometry model containing the entities.\nents: A single entity or a vector of entities to rotate.\nX::AbstractVector{<:Real}: Point on the rotation axis [x, y, z].\nA::AbstractVector{<:Real}: Axis direction vector [ax, ay, az].\nangle::Real: Rotation angle in radians.\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.rotate-Tuple{Mesh}","page":"Reference","title":"Serendip.rotate","text":"rotate(mesh; base=[0,0,0], axis=[0,0,1], angle=90.0)\n\nRotates a Mesh object mesh according to a base point, an axis vector and an angle.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.save-Tuple{FEModel, String}","page":"Reference","title":"Serendip.save","text":"save(domain, filename)\n\nSaves a domain object into a file. Available formats are vtu, vtk and xml.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.save-Tuple{Serendip.AbstractDomain, String}","page":"Reference","title":"Serendip.save","text":"save(mesh, filename, quiet=true)\n\nSaves a mesh object into a file. Available formats are vtu and vtk.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.scale-Tuple{Block}","page":"Reference","title":"Serendip.scale","text":"scale\n\nScales a block from the point base using the given factor. If axis is provided, the scaling is performent only in the axis direction.\n\nExamples\n\njulia> block = Block([ 0 0; 1 1 ], nx=2, ny=2);\n\njulia> get_coords(block)\n4×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 1.0  0.0  0.0\n 1.0  1.0  0.0\n 0.0  1.0  0.0\n\njulia> scale(block, factor=0.5, base=[ 0, 0 ], axis=[ 1, 0 ]);\n\njulia> get_coords(block)\n4×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.5  0.0  0.0\n 0.5  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.select-Tuple{Serendip.AbstractDomain, Symbol, Vararg{Union{Expr, String, Symbol, CellShape, Symbolic, NTuple{N, Symbolic} where N, Vector{<:Real}}}}","page":"Reference","title":"Serendip.select","text":"select(domain::AbstractDomain, kind::Symbol, selectors...; invert=false, tag=\"\")\n\nFilters entities from a finite element domain (domain) by type and selection criteria.\n\nArguments\n\ndomain::AbstractDomain: The mesh or domain containing entities.\nkind::Symbol: One of :element, :face, :edge, or :node to specify which entity to select.\nselectors: One or more selectors.\n\nSelectors can be:\n\n:all             → select all elements (no filtering)\n:bulk, :line, :contact, :cohesive, :line_interface, :tip → select by element role\n:active          → select only active elements\n:embedded        → select embedded line elements (with couplings)\nString           → match element tag\nExpr or Symbolic → spatial condition using coordinates x, y, z\nVector{Int}      → list of element indices to select\nNTuple{N, Symbolic} → multiple symbolic coordinate conditions\n\nKeyword Arguments\n\ninvert::Bool: If true, returns the entities not matching the selectors.\ntag::String: If non-empty, assigns this tag to all selected entities.\n\nReturns\n\nA list of selected entities of the specified kind.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.select-Tuple{Vector{<:Serendip.AbstractCell}, Vararg{Union{Expr, String, Symbol, Symbolic, NTuple{N, Symbolic} where N, Vector{Int64}}}}","page":"Reference","title":"Serendip.select","text":"select(elems::Vector{<:AbstractCell}, selectors...; invert=false, tag=\"\")\n\nFilters a list of finite element cells (elems) based on one or more selectors.\n\nSelectors can be:\n\n:all             → select all elements (no filtering)\n:cont, :bulk, :line, :contact, :cohesive, :line_interface, :tip → select by element role\n:active          → select only active elements\n:embedded        → select embedded line elements (with couplings)\nString           → match element tag\nExpr or Symbolic → spatial condition using coordinates x, y, z\nVector{Int}      → list of element indices to select\nNTuple{N, Symbolic} → multiple symbolic coordinate conditions\n\nKeyword Arguments\n\ninvert::Bool: If true, returns the complement of the selected set.\ntag::String: If non-empty, assigns this tag to all selected elements.\n\nReturns\n\nA filtered list of elements matching the criteria.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.set_recombine-Tuple{GeoModel, Any}","page":"Reference","title":"Serendip.set_recombine","text":"set_recombine(geo, ent)\n\nEnable element recombination for a surface entity ent in the geometric model geo.   This converts triangular subdivisions into quadrilateral elements during meshing.\n\nArguments\n\ngeo::GeoModel: Geometry model containing the surface.\nent: Surface entity where recombination is applied.\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.set_refinement-Tuple{GeoModel, Vector{<:Real}, Vararg{Real, 5}}","page":"Reference","title":"Serendip.set_refinement","text":"set_refinement(geo, X, rx, ry, rz, size1, size2; gradient=0.1, roundness=0.5)\n\nRegister a mesh-refinement field centered at X. The field targets element size size1 near X, transitioning to size2 away from it. The radii rx, ry, and rz set the extents along the x/y/z axes.\n\nArguments\n\ngeo::GeoModel            : geometry model.\nX::AbstractVector{<:Real}: 3D center [x, y, z].\nrx::Real                 : extent along x.\nry::Real                 : extent along y.\nrz::Real                 : extent along z.\nsize1::Real              : inner target size.\nsize2::Real              : outer target size.\n\nKeywords\n\ngradient::Real (>0) = 0.1 : transition gradient from size1 to size2 (0 = sharp, 1 = linear).\nroundness::Real ∈ [0,1] = 0.5 : shape of the refinement region (0 = box-like, 1 = ellipsoidal).\n\nExample\n\nset_refinement(geo, [0.5, 0.5, 0.5], 10.0, 20.0, 15.0, 0.1, 0.5;\n               gradient=0.5, roundness=0.8)\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.set_size-Tuple{GeoModel, Real}","page":"Reference","title":"Serendip.set_size","text":"set_size(geo::GeoModel, size::Real)\n\nSets the maximum mesh size for all entities in the Gmsh-based geometry model.\n\nArguments\n\ngeo::GeoModel: The geometry model whose mesh settings will be modified.\nsize::Real: The desired global mesh size.\n\nExample\n\nset_size(geo, 0.05)  # Set global mesh size to 0.05 units\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.set_size-Tuple{GeoModel, Symbol, String, Real}","page":"Reference","title":"Serendip.set_size","text":"set_size(geo, kind, tag, size)\n\nAssigns a local mesh size to all points on the boundary of entities selected by type (kind) and tag within a GeoModel.\n\nThis function selects entities of a specific geometric type (:point, :edge, :surface, :volume) and tag, and sets the mesh size at the corresponding points.\n\nArguments\n\ngeo::GeoModel: The geometry model where the mesh size is applied.\nkind::Symbol: Type of geometric entity to target (:point,:edge, :face, :volume).\ntag::String: Tag string used to select the target entities.\nsize::Real: Target mesh size to assign at the boundary points of the selected entities.\n\nExample\n\nset_size(geo, :surface, \"foundation_zone\", 0.05)\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.set_size-Tuple{GeoModel, Union{Serendip.GeoEntity, Vector{<:Serendip.GeoEntity}}, Real}","page":"Reference","title":"Serendip.set_size","text":"set_size(geo, target, size)\n\nAssigns a target mesh size to the point entities on the boundary of the given target geometry entity or entities. If a single GeoEntity is passed, it is internally wrapped in a vector.\n\nArguments\n\ngeo::GeoModel: The geometry model where the mesh size will be assigned.\ntarget::Union{GeoEntity,Vector{<:GeoEntity}: A single GeoEntity or a vector of them.\nsize::Real: The target mesh size to assign to the boundary points of the given entities.\n\nExample\n\nset_size(geo, some_line_entity, 0.05)\nset_size(geo, [curve1, surface1], 0.1)\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.set_transfinite_curve-Tuple{GeoModel, Any, Any}","page":"Reference","title":"Serendip.set_transfinite_curve","text":"set_transfinite_curve(geo, curve, num_nodes)\n\nDefine a transfinite discretization along a curve entity curve in the geometric model geo,   specifying the number of mesh nodes to distribute along it.\n\nArguments\n\ngeo::GeoModel: Geometry model containing the curve.\ncurve: Curve entity (typically an Edge) to be meshed with transfinite spacing.\nnum_nodes::Int: Number of nodes along the curve, including endpoints.\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.set_transfinite_surface-Tuple{GeoModel, Any}","page":"Reference","title":"Serendip.set_transfinite_surface","text":"set_transfinite_surface(geo, surface)\n\nAssign a transfinite mesh distribution to a surface entity surface in the geometric model geo.   Used to ensure structured meshing consistent with adjoining transfinite curves.\n\nArguments\n\ngeo::GeoModel: Geometry model containing the surface.\nsurface: Surface entity to be meshed transfinetely.\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.set_transfinite_volume-Tuple{GeoModel, Any}","page":"Reference","title":"Serendip.set_transfinite_volume","text":"set_transfinite_volume(geo, volume)\n\nAssign a transfinite mesh distribution to a volume entity volume in the geometric model geo.   Ensures structured, block-like hexahedral meshing compatible with transfinite boundaries.\n\nArguments\n\ngeo::GeoModel: Geometry model containing the volume.\nvolume: Volume entity to be meshed using transfinite interpolation.\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.slice-Tuple{Serendip.AbstractDomain}","page":"Reference","title":"Serendip.slice","text":"slice(mesh; base, axis)\n\nGenerates a planar mesh by slicing a 3D mesh using a plane defined by a base point and an axis. The original nodal data is interpolated to the nodes of the resulting mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.split_by-Tuple{DataTable, String}","page":"Reference","title":"Serendip.split_by","text":"split_by(table::DataTable, col_name::String)\n\nSplits a DataTable into a vector of new DataTables based on the unique values in a specified column.\n\nThis is an efficient implementation that makes a single pass over the data to group row indices before creating the new tables. The resulting tables are not guaranteed to be in any specific order.\n\nArguments\n\ntable::DataTable: The input table to split.\ncol_name::String: The name of the column whose values will be used to group the rows.\n\nReturns\n\nVector{DataTable}: A vector of new DataTable objects, where each table corresponds to a unique value in the col_name column.\n\nExample\n\nheader = [\"ID\", \"Category\", \"Value\"]\ncolumns = [\n    [1, 2, 3, 4, 5, 6],\n    [\"A\", \"B\", \"A\", \"C\", \"B\", \"A\"],\n    [10.1, 20.2, 10.3, 30.1, 20.4, 10.5]\n]\ndt = DataTable(header, columns, name=\"SalesData\")\ngrouped_tables = split_by(dt, \"Category\")\n\n\n\n\n\n","category":"method"},{"location":"api/reference/#Serendip.translate-Tuple{GeoModel, Vararg{Any, 4}}","page":"Reference","title":"Serendip.translate","text":"translate(geo, ents, dx, dy, dz)\n\nTranslate one or more entities ents in the geometric model geo by the displacement components (dx, dy, dz).\n\nArguments\n\ngeo::GeoModel: Geometry model containing the entities.\nents: A single entity or a vector of entities to translate.\ndx::Real: Translation along the x-axis.\ndy::Real: Translation along the y-axis.\ndz::Real: Translation along the z-axis.\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"#Introduction-to-Serendip","page":"Introduction","title":"Introduction to Serendip","text":"Serendip is a finite element library written in Julia. The project focuses on research and implementation of formulations and constitutive models for structural analysis.","category":"section"},{"location":"#Installation-and-basic-usage","page":"Introduction","title":"Installation and basic usage","text":"Install the package using the package manager, type ] and then:\n\n] add Serendip\n\nTo use Serendip in Julia REPL:\n\nusing Serendip\n\nTo test:\n\n] test Serendip","category":"section"},{"location":"#Documentation-map","page":"Introduction","title":"Documentation map","text":"The documentation is organized in two complementary tracks:\n\nManual: curated guidance, workflow notes, and tutorial-style pages.\nAPI Reference: full exported API surface generated from docstrings.","category":"section"}]
}
