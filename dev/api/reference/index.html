<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Serendip</title><meta name="title" content="Reference · Serendip"/><meta property="og:title" content="Reference · Serendip"/><meta property="twitter:title" content="Reference · Serendip"/><meta name="description" content="Documentation for Serendip."/><meta property="og:description" content="Documentation for Serendip."/><meta property="twitter:description" content="Documentation for Serendip."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Serendip</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../manual/workflow/">Workflow</a></li><li><a class="tocitem" href="../../manual/tutorials/">Tutorials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/overview/">Overview</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NumericalForge/Serendip.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page is generated from exported symbols in <code>Serendip</code>.</p><article><details class="docstring" open="true"><summary id="Serendip.Serendip"><a class="docstring-binding" href="#Serendip.Serendip"><code>Serendip.Serendip</code></a> — <span class="docstring-category">Module</span></summary><section><div><p><strong>Serendip.jl</strong></p><p>Serendip module implements functions and types to perform finite element analyses.</p><p><strong>Important data types</strong></p><p>Node, Element, Model, Dof, Ip, NodeBC, SurfaceBC</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.AsinhYieldCohesive"><a class="docstring-binding" href="#Serendip.AsinhYieldCohesive"><code>Serendip.AsinhYieldCohesive</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AsinhYieldCohesive(; E, nu=0.0, ft, fc, zeta=5.0, wc, GF, ft_law=:hordijk, alpha=1.5, gamma=0.1, theta=1.5)</code></pre><p>Constitutive model for cohesive elements with a power-lay yield surface ans ft<em>law in tension.   The tensile ft</em>law branch is regularized through a measure of the bulk element size <code>h</code> to ensure mesh-objective fracture energy dissipation.</p><p><strong>Keyword arguments</strong></p><ul><li><code>E::Real</code>:   Young’s modulus from the bulk material (must be &gt; 0).</li><li><code>nu::Real</code>:   Poisson’s ratio (0 ≤ ν &lt; 0.5).</li><li><code>fc::Real</code>:   Compressive strength (&lt; 0).<ul><li><code>ft::Real</code>:  </li></ul>Tensile strength (&gt; 0).</li><li><code>wc::Real</code>:   Critical crack opening (must be &gt; 0 if given). Can be specified alternatively to <code>GF</code>.</li><li><code>mu::Real</code>:   Friction coefficient (&gt; 0).</li><li><code>GF::Real</code>:   Fracture energy (must be &gt; 0 if given). Can be specified alternatively to <code>wc</code>.</li><li><code>ft_law::Union{Symbol,AbstractSpline} = :hordijk</code>:   Softening law for post-peak tensile response. Options are: <code>:linear</code>, <code>:bilinear</code>, <code>:hordijk</code>, <code>:soft</code> or a custom function.</li><li><code>alpha::Real = 0.6</code>:   Parameter to control the shape of the yield surface (α &gt; 0.5).</li><li><code>gamma::Real = 0.1</code>:   Parameter to control the residual shear strength (γ ≥ 0).</li><li><code>theta::Real = 1.5</code>:   Parameter to control the rate of reduction of shear strength (θ ≥ 0).</li><li><code>zeta::Real = 5.0</code>:   Factor to control elastic relative displacements in cohesive formulations (≥ 0).</li></ul><p><strong>Returns</strong></p><p>A <code>AsinhYieldCohesive</code> object.</p><p><strong>Notes</strong></p><ul><li>Either <code>wc</code> or <code>GF</code> must be provided. If only <code>GF</code> is given, <code>wc</code> is computed internally based on the chosen ft_law.</li><li>The frictional contribution is governed by <code>mu</code>.</li><li>Normal and shear stiffnesses (<code>kn</code>, <code>ks</code>) are computed from the mechanical properties of the bulk material and the characteristic length <code>h</code> of the adjacent bulk elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.CebBondSlip"><a class="docstring-binding" href="#Serendip.CebBondSlip"><code>Serendip.CebBondSlip</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CebBondSlip(; taumax, taures=0.0, s1, s2, s3, alpha=0.4, ks=taumax/s1, kn)</code></pre><p>Constitutive model for bond–slip behavior of a reinforcing bar embedded in a solid, according to the CEB (Comité Euro-International du Béton) formulation.</p><p><strong>Parameters</strong></p><ul><li><code>taumax::Float64</code> : Peak shear strength (&gt; 0).</li><li><code>taures::Float64</code> : Residual shear stress (≥ 0, must be &lt; τmax).</li><li><code>s1::Float64</code> : Characteristic slip defining the end of the ascending branch (&gt; 0).</li><li><code>s2::Float64</code> : Characteristic slip at the start of the softening branch (&gt; 0).</li><li><code>s3::Float64</code> : Characteristic slip where residual shear stress is reached (&gt; 0).</li><li><code>alpha::Float64</code> : Curvature parameter for the ascending branch (0 ≤ α ≤ 1, default 0.4).</li><li><code>ks::Float64</code> : Initial shear stiffness (default = τmax/s1, must satisfy ks ≥ τmax/s₁).</li><li><code>kn::Float64</code> : Normal stiffness of the interface (&gt; 0).</li></ul><p><strong>Notes</strong></p><ul><li>The model defines the shear stress–slip relation in three branches: ascending (0–s1), softening (s2–s3), and residual plateau (≥ s3).</li><li>Default <code>ks</code> ensures consistency with the initial slope of the bond law.</li><li>The normal stiffness <code>kn</code> penalizes opening displacement at the interface.</li></ul><p><strong>References</strong></p><p>CEB-FIP Model Code recommendations for bond–slip laws in reinforced concrete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.Chart"><a class="docstring-binding" href="#Serendip.Chart"><code>Serendip.Chart</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Chart(; 
    size=(220,150), font=&quot;NewComputerModern&quot;, font_size=7.0,
    xlimits, ylimits, aspect_ratio=:auto,
    xmult=1.0, ymult=1.0, xbins=7, ybins=6,
    xlabel=&quot;$x$&quot;, ylabel=&quot;$y$&quot;,
    xticks=Float64[], yticks=Float64[],
    xtick_labels=String[], ytick_labels=String[],
    legend=:top_right, legend_font_size=0,
    quiet=false)</code></pre><p>Construct a 2D chart figure with axes, legend, and optional tick customization.</p><p><strong>Arguments</strong></p><ul><li><code>size::Tuple{Int,Int}</code>: width × height in points. 1 cm = 28.35 points.</li><li><code>font::AbstractString</code>: font family for axes and legend.</li><li><code>font_size::Real</code>: base font size.</li><li><code>xlimits::Vector{&lt;:Real}</code>, <code>ylimits::Vector{&lt;:Real}</code>: axis limits <code>[min,max]</code>; use empty vectors for auto scaling.</li><li><code>aspect_ratio::Symbol</code>: <code>:auto</code> or <code>:equal</code>.</li><li><code>xmult::Real</code>, <code>ymult::Real</code>: multiplicative factors applied to tick values.</li><li><code>xbins::Int</code>, <code>ybins::Int</code>: target number of major ticks.</li><li><code>xlabel::AbstractString</code>, <code>ylabel::AbstractString</code>: axis labels.</li><li><code>xticks::Vector{&lt;:Real}</code>, <code>yticks::Vector{&lt;:Real}</code>: explicit tick positions; empty vectors enable auto ticks.</li><li><code>xtick_labels::Vector{&lt;:AbstractString}</code>, <code>ytick_labels::Vector{&lt;:AbstractString}</code>: custom tick labels; if provided, lengths must match the corresponding tick arrays.</li><li><code>legend::Symbol</code>: legend location (e.g., <code>:top_right</code>, <code>:top_left</code>, <code>:bottom_left</code>, <code>:outer_right</code>).</li><li><code>legend_font_size::Real</code>: legend font size; <code>0</code> uses <code>font_size</code>.</li><li><code>quiet::Bool</code>: suppress constructor log.</li></ul><p><strong>Notes</strong></p><ul><li>Use <code>add_series</code> to append data series to the chart.</li><li>Use <code>save</code> to export the chart to a file.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Chart</code> object.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ch = Chart(size=(300,200),
           xlabel=&quot;Time [s]&quot;,
           ylabel=&quot;Displacement [mm]&quot;,
           xlimits=[0.0,10.0],
           ylimits=[-5.0,5.0],
           legend=:bottom_right)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.Context"><a class="docstring-binding" href="#Serendip.Context"><code>Serendip.Context</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Context(; ndim=3, stress_state=:auto, transient=nothing, thickness=1.0, g=0.0, T0=0.0)</code></pre><p>Defines global analysis metadata and configuration parameters for the finite element model.</p><p>This struct encapsulates the physical and numerical context in which the FE model is defined, including dimensionality, stress state, analysis type, and environmental parameters such as gravity and reference temperature.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>ndim::Int=3</code>: Number of spatial dimensions.</p><ul><li><code>3</code> for 3D analysis.</li><li><code>2</code> for 2D analysis.</li></ul></li><li><p><code>stress_state::Symbol=:auto</code>: Stress state for 2D problems. Accepted values:</p><ul><li><code>:auto</code> — Automatically determined from geometry and settings.</li><li><code>:plane_stress</code> — Plane stress assumption (e.g., thin plates).</li><li><code>:plane_strain</code> — Plane strain assumption (e.g., long tunnels).</li><li><code>:axisymmetric</code> — Axisymmetric assumption for rotationally symmetric models.</li></ul></li><li><p><code>transient::Flag=nothing</code>: Flag for transient analysis. Accepted values:</p><ul><li><code>true</code> — Transient (time-dependent) analysis.</li><li><code>false</code> — Steady-state analysis.</li><li><code>nothing</code> — Auto-detect based on problem setup.</li></ul></li><li><p><code>thickness::Float64=1.0</code>: Thickness for 2D analyses. Ignored for 3D problems.</p></li><li><p><code>g::Float64=0.0</code>: Gravity acceleration.</p></li><li><p><code>T0::Float64=0.0</code>: Reference temperature for thermal effects (if applicable).</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ctx = Context(ndim=2, stress_state=:plane_strain, thickness=0.1, g=9.81)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.CyclicBondSlip"><a class="docstring-binding" href="#Serendip.CyclicBondSlip"><code>Serendip.CyclicBondSlip</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CyclicBondSlip(; taumax, taures, speak, sres, alpha=0.4, beta=1.0, ks, kn, p)</code></pre><p>Constitutive model for a cyclic rod–solid bond interface with degradation. The shear bond law uses a piecewise envelope: power-law hardening up to <code>speak</code>, a short plateau, then softening toward <code>taures</code>. Under cyclic loading, the envelope evolves with the reversal amplitude.</p><p><strong>Arguments</strong></p><ul><li><code>taumax::Real</code> Initial peak bond stress τ_max (&gt; 0).</li><li><code>taures::Real</code> Residual bond stress τ<em>res (≥ 0, &lt; τ</em>max).</li><li><code>speak::Real</code> Slip at initial peak stress (&gt; 0).</li><li><code>sres::Real</code> Slip where the envelope reaches τ_res (&gt; 0).</li><li><code>alpha::Real=0.4</code> Exponent for the ascending branch (0 ≤ α ≤ 1).</li><li><code>beta::Real=1.0</code> Exponent for the descending branch (0 ≤ β ≤ 1).</li><li><code>ks::Real</code> Shear stiffness (&gt; 0) with constraint <code>ks ≥ taumax/speak</code>.</li><li><code>kn::Real</code> Normal stiffness (&gt; 0).</li><li><code>p::Real</code> Interface perimeter (&gt; 0).</li></ul><p><strong>Behavior</strong></p><ul><li>Cyclic effects: peak τ_max decays, <code>speak</code> shifts, and <code>taures</code> evolves with a measure of reversal amplitude and accumulated slip (handled via internal state).</li><li>Tangent shear stiffness equals the envelope derivative in inelastic updates, or <code>ks</code> when elastic.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CyclicBondSlip</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.DataTable"><a class="docstring-binding" href="#Serendip.DataTable"><code>Serendip.DataTable</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DataTable(header, columns=Vector[]; name=&quot;&quot;)
DataTable(; pairs...)
DataTable(header, matrix; name=&quot;&quot;)
DataTable(filename, delim=&#39;\t&#39;)</code></pre><p>Construct a tabular container with named columns.</p><p><strong>Arguments</strong></p><ul><li><code>header::AbstractArray</code>: column names (strings or symbols).</li><li><code>columns::Vector{&lt;:AbstractVector}</code>: one vector per column. All columns must have the same length.</li><li><code>name::AbstractString</code>: optional table name.</li><li><code>pairs...</code>: keyword form <code>colName = vector</code>. A special key <code>name</code> sets the table name.</li><li><code>matrix::AbstractMatrix</code>: a 2D array whose columns become table columns.</li><li><code>filename::AbstractString</code>: path to a delimited text file (<code>.dat</code>, <code>.table</code>, <code>.json</code>).</li><li><code>delim::Char</code>: column delimiter when reading from file (default <code>&#39;\t&#39;</code>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">DataTable([&quot;x&quot;,&quot;y&quot;], [[1,2,3], [10.0, 20.0, 30.0]]; name=&quot;XY&quot;)
DataTable(x=[1,2,3], y=[10.0,20.0,30.0], name=&quot;XY&quot;)
DataTable([&quot;a&quot;,&quot;b&quot;], [1 2; 3 4; 5 6]; name=&quot;M&quot;)
DataTable(&quot;data.table&quot;)                # reads header + data from file</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.Dof"><a class="docstring-binding" href="#Serendip.Dof"><code>Serendip.Dof</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>Dof()</code></p><p>Creates an object that represents a Degree of Freedom in a finite element analysis. <code>Node</code> objects include a field called <code>dofs</code> which is an array of <code>Dof</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.DomainPlot"><a class="docstring-binding" href="#Serendip.DomainPlot"><code>Serendip.DomainPlot</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DomainPlot(mesh; 
    size=(220,150), face_color=:aliceblue, warp=0.0,
    edge_width=0.3, edge_color=:auto, outline_width=0.4,
    line_elem_width=0.6,
    field=&quot;&quot;, limits=Float64[], field_kind=:auto, field_mult=1.0,
    label=&quot;&quot;, colormap=:coolwarm, diverging=false,
    colorbar=:right, colorbar_ratio=0.9, bins=6,
    font=&quot;NewComputerModern&quot;, font_size=7.0,
    interpolation=:linear,
    azimuth=30, elevation=30, distance=0.0,
    feature_edges=true, view_mode=:surface_with_edges,
    light_vector=[0,0,0],
    node_labels=false,
    axes=:none, axis_labels=String[],
    quiet=false)</code></pre><p>Create a customizable domain plot for meshes and FE models.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::Union{AbstractDomain,FEModel}</code>: object to plot.</li></ul><p><strong>Keywords</strong></p><ul><li><code>size::Tuple{Int,Int}</code>: figure size in pt. (1 cm = 28.35 pt).</li><li><code>face_color::Symbol</code>: surface color for area/surface elements.</li><li><code>warp::Real</code>: displacement scale factor for warped views.</li><li><code>edge_width::Real</code>: internal edge width for area/surface cells.</li><li><code>edge_color::Union{Tuple,Symbol}</code>: edge color; <code>:auto</code> darkens face color.</li><li><code>outline_width::Real</code>: boundary outline width.</li><li><code>line_elem_width::Real</code>: stroke width for line elements (bars/beams).</li><li><code>field::AbstractString</code>: scalar field name for coloring; empty disables.</li><li><code>limits::Vector{&lt;:Real}</code>: field range <code>[min,max]</code>; empty vector enables auto range.</li><li><code>field_kind::Symbol</code>: <code>:auto | :none | :node | :element</code>.</li><li><code>field_mult::Real</code>: multiplier applied to field values.</li><li><code>label::AbstractString</code>: colorbar label.</li><li><code>colormap::Union{Symbol,Colormap}</code>: e.g. <code>:viridis</code>, <code>:coolwarm</code>, or a <code>Colormap</code>.</li><li><code>diverging::Bool</code>: center colormap at zero.</li><li><code>colorbar::Symbol</code>: <code>:none | :right | :bottom</code>.</li><li><code>colorbar_ratio::Real</code>: colorbar length scale (&gt; 0).</li><li><code>bins::Int</code>: number of colorbar bins.</li><li><code>font::AbstractString</code>: font family.</li><li><code>font_size::Real</code>: font size (&gt; 0).</li><li><code>interpolation::Symbol</code>: <code>:constant | :linear | :nonlinear</code> surface shading.</li><li><code>azimuth::Real</code>: 3D azimuth angle in degrees.</li><li><code>elevation::Real</code>: 3D elevation angle in degrees.</li><li><code>distance::Real</code>: camera distance (≥ 0).</li><li><code>feature_edges::Bool</code>: enhance feature lines (<code>:outline</code> forces on).</li><li><code>view_mode::Symbol</code>: <code>:surface_with_edges | :surface | :wireframe | :outline</code>.</li><li><code>light_vector::Vector{&lt;:Real}</code>: light direction.</li><li><code>node_labels::Bool</code>: show node ids.</li><li><code>axes::Symbol</code>: axes widget location (see <code>_axes_widget_locations</code>).</li><li><code>axis_labels::Vector{&lt;:AbstractString}</code>: custom axis labels; defaults to <code>[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]</code>.</li><li><code>quiet::Bool</code>: suppress constructor log.</li></ul><p><strong>Notes</strong></p><ul><li>Use <code>save</code> to export the figure to a file.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">plt = DomainPlot(model;
                 field=&quot;ux&quot;, field_kind=:node, warp=50.0,
                 colormap=:viridis, colorbar=:right, label=&quot;uₓ [mm]&quot;,
                 view_mode=:surface_with_edges, feature_edges=true)
save(plt, &quot;model_plot.pdf&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.DruckerPrager"><a class="docstring-binding" href="#Serendip.DruckerPrager"><code>Serendip.DruckerPrager</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DruckerPrager(; E, nu=0.0, alpha=0.0, kappa=0.0, H=0.0, rho=0.0)</code></pre><p>Linear-elastic constitutive model with Drucker–Prager yield criterion and linear isotropic hardening. The model combines elastic response, pressure-dependent plastic yielding, and optional linear hardening.</p><p><strong>Arguments</strong></p><ul><li><code>E::Float64</code>: Young’s modulus (must be &gt; 0.0).</li><li><code>nu::Float64</code>: Poisson’s ratio (0.0 ≤ ν &lt; 0.5).</li><li><code>alpha::Float64</code>: Drucker–Prager friction parameter (&gt; 0.0).</li><li><code>kappa::Float64</code>: Drucker–Prager cohesion parameter (&gt; 0.0).</li><li><code>H::Float64</code>: Hardening modulus (≥ 0.0). A value of 0.0 corresponds to perfect plasticity.</li><li><code>rho::Float64</code>: Constitutive density (≥ 0.0).</li></ul><p><strong>State Variables</strong></p><p>Stored internally in <code>DruckerPragerState</code>:</p><ul><li><code>σ::Vec6</code>: Stress tensor (Mandel notation).</li><li><code>ε::Vec6</code>: Strain tensor (Mandel notation).</li><li><code>εpa::Float64</code>: Accumulated plastic strain.</li><li><code>Δλ::Float64</code>: Plastic multiplier increment.</li></ul><p><strong>Notes</strong></p><ul><li><code>alpha</code> and <code>kappa</code> define the Drucker–Prager yield surface.</li><li>Linear isotropic hardening is controlled by <code>H</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.DynamicAnalysis"><a class="docstring-binding" href="#Serendip.DynamicAnalysis"><code>Serendip.DynamicAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DynamicAnalysis(model::FEModel; outdir=&quot;&quot;, outkey=&quot;&quot;)</code></pre><p>Create a dynamic mechanical analysis for the given finite element model.</p><p><strong>Arguments</strong></p><ul><li><code>model::FEModel</code>: Finite element model definition.</li><li><code>outdir::String</code>: Directory for output files. Defaults to <code>&quot;./output&quot;</code>.</li><li><code>outkey::String</code>: Key prefix for output files. Defaults to <code>&quot;out&quot;</code>.</li></ul><p><strong>Behavior</strong></p><ul><li>Initializes an <code>AnalysisData</code> instance with the given output settings.</li><li>If <code>model.ctx.stress_state == :auto</code> and <code>model.ctx.ndim == 2</code>, the stress state is set to <code>:plane_strain</code>.</li><li>Marks the analysis as transient (<code>this.data.transient = true</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = FEModel(mapper)
analysis = DynamicAnalysis(model; outdir=&quot;results&quot;, outkey=&quot;run1&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.FEModel-Tuple{Mesh, RegionMapper}"><a class="docstring-binding" href="#Serendip.FEModel-Tuple{Mesh, RegionMapper}"><code>Serendip.FEModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FEModel(mesh::Mesh, mapper::RegionMapper;
        ndim::Int=0, stress_state::Symbol=:auto, thickness::Real=1.0, 
        g::Real=0.0, T0::Real=0.0, quiet::Bool=false)</code></pre><p>Construct a finite element model from a <code>Mesh</code> and a <code>RegionMapper</code>.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::Mesh</code>: Discretized geometry containing nodes, elements, faces, and edges.</li><li><code>mapper::RegionMapper</code>: Provides mapping rules between geometric entities, element formulations, and constitutive models.</li><li><code>ndim::Int=0</code>: Spatial dimension of the analysis (default uses <code>mesh.ctx.ndim</code>).</li><li><code>stress_state::Symbol=:auto</code>: Stress assumption (<code>:plane_stress</code>, <code>:plane_strain</code>, <code>:axisymmetric</code>, <code>:auto</code>).</li><li><code>thickness::Real=1.0</code>: Domain thickness for 2D analyses.</li><li><code>g::Real=0.0</code>: Gravity acceleration.</li><li><code>T0::Real=0.0</code>: Reference temperature.</li><li><code>quiet::Bool=false</code>: Suppress console output if <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>FEModel</code>: Finite element model with nodes, elements, faces, edges, and context fully configured.</li></ul><p><strong>Notes</strong></p><ul><li>Checks compatibility between element formulations and constitutive models.</li><li>Initializes nodes, elements, integration points, quadrature, and couplings.</li><li>Prints model statistics unless <code>quiet=true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.GPath"><a class="docstring-binding" href="#Serendip.GPath"><code>Serendip.GPath</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GPath(path; embedded=false, shape=LIN3, tag=&quot;&quot;, interface_tag=&quot;&quot;, tip_tag=&quot;&quot;, tips=:none)</code></pre><p>Creates a geometric path (<code>GPath</code>) entity, which represents a curve (typically a sequence of connected edges) embedded or placed in the geometry model. This structure is typically used to represent linear inclusions such as reinforcements, drains, etc. If embedded is <code>false</code>, interface elements will be created along the path. If <code>tips</code> is not <code>:none</code>, tip elements will be created at the endpoints of the path.</p><p><strong>Arguments</strong></p><ul><li><code>path::Path</code>: The geometric path (sequence of edges and points) to be wrapped as a GPath.</li><li><code>embedded::Bool=false</code>: Whether this path should be embedded in the bulk mesh during meshing (e.g. cracks, reinforcements).</li><li><code>shape::CellShape=LIN3</code>: Shape function used for discretizing the path (e.g., quadratic line <code>LIN3</code>, cubic, etc.).</li><li><code>tag::String=&quot;&quot;</code>: Optional label or name for this path (e.g. to identify or filter later).</li><li><code>interface_tag::String=&quot;&quot;</code>: Optional tag for use when interface elements are generated from the path.</li><li><code>tips::Symbol=:none</code>: Specify witch tips are considered (:start, :end, :both, :none) for the generation of tip interface elements.</li><li><code>tip_tag::String=&quot;&quot;</code>: Optional tag for tip elements if tip elements are enabled.</li></ul><p>Note: Original OCC edges are removed from the geometry after constructing the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.GeoModel"><a class="docstring-binding" href="#Serendip.GeoModel"><code>Serendip.GeoModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GeoModel(; size=0.0, quiet = false)</code></pre><p>Creates a new geometry model (<code>GeoModel</code>) using Gmsh&#39;s OpenCASCADE (OCC) backend or blocks for structured meshing. This struct serves as a container for user-defined geometry entities and geometric paths (e.g., composed by line or arc definitions).</p><p><strong>Arguments</strong></p><ul><li><code>size::Real=0.0</code>: If greater than zero, sets the maximum element size for all entities in the model.</li><li><code>quiet::Bool=false</code>: If <code>true</code>, suppresses Gmsh initialization messages in the console.</li></ul><p><strong>Fields Initialized</strong></p><ul><li><code>entities</code>: A dictionary mapping Gmsh entity identifiers <code>(dim, tag)</code> to <code>GeoEntity</code> objects explicitly added by the user.</li><li><code>blocks</code>: A list of meshing <code>Block</code> structures used for meshing control or volume/surface definitions.</li><li><code>gpaths</code>: A list of <code>GPath</code> objects used to represent embedded geometric paths (e.g., for reinforcement, interfaces, or spring elements).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">geo = GeoModel(size=0.5)       # set the maximum element size
geo = GeoModel(quiet=true)     # silent initialization</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.Ip"><a class="docstring-binding" href="#Serendip.Ip"><code>Serendip.Ip</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>Ip(R, w)</code></p><p>Creates an <code>Ip</code> object that represents an Integration Point in finite element analyses. <code>R</code> is a vector with the integration point local coordinates and <code>w</code> is the corresponding integration weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.LinearContact"><a class="docstring-binding" href="#Serendip.LinearContact"><code>Serendip.LinearContact</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearContact(; kn, ks)</code></pre><p>Unilateral linear elastic interface (contact) model.</p><p>Applies a penalty-type relation between relative displacement and traction in compression and shear. In the normal direction, the response is linear elastic in compression but traction is zero in tension. The shear response is linear elastic according to <code>ks</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>kn::Float64</code> Normal stiffness (&gt; 0).</li><li><code>ks::Float64</code> Shear stiffness (≥ 0).</li></ul><p><strong>Returns</strong></p><p>A <code>LinearContact</code> constitutive object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.LinearElastic"><a class="docstring-binding" href="#Serendip.LinearElastic"><code>Serendip.LinearElastic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearElastic(; E=1.0, nu=0.0)</code></pre><p>Linear elastic isotropic material model. This model can be used with bulk elements (e.g. solids), beams, bars, and shells. It assumes small deformations and linear stress-strain response.</p><p><strong>Parameters</strong></p><ul><li><code>E</code>: Young&#39;s modulus. Must be positive.</li><li><code>nu</code>: Poisson&#39;s ratio. Must satisfy <code>0 ≤ ν &lt; 0.5</code>.</li></ul><p>The shear correction factor <code>alpha_s</code> (defaulting to 5/6 for some formulations) is not a direct parameter of this constitutive model but is handled by the element formulations (e.g., <code>MechBeam</code>, <code>MechShell</code>) that use it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.LinearInterface"><a class="docstring-binding" href="#Serendip.LinearInterface"><code>Serendip.LinearInterface</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearInterface(; kn, ks)</code></pre><p>Bilateral linear elastic interface model.</p><p>Applies a penalty-type relation between relative displacement and traction in both normal and shear directions. The normal response is linear in both tension and compression; the shear response is linear elastic according to <code>ks</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>kn::Float64</code>  Normal stiffness (&gt; 0).</li><li><code>ks::Float64</code>  Shear stiffness (≥ 0).</li></ul><p><strong>Returns</strong></p><p>A <code>LinearInterface</code> constitutive object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.LinearTip"><a class="docstring-binding" href="#Serendip.LinearTip"><code>Serendip.LinearTip</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearTip(; k)</code></pre><p>Constitutive model for a linear tip spring. Used to model the elastic response at the tips of bar or beam elements inside bulk material. Transmits tension and compression.</p><p><strong>Arguments</strong></p><ul><li><code>k::Real</code> Stiffness (≥ 0). Reaction update: <code>Δf = k·Δw</code>.</li></ul><p><strong>Notes</strong></p><ul><li><code>w</code> is the relative tip displacement along the element axis.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>LinearTip</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.MechAnalysis"><a class="docstring-binding" href="#Serendip.MechAnalysis"><code>Serendip.MechAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MechAnalysis(model::FEModel; outdir=&quot;&quot;, outkey=&quot;&quot;)</code></pre><p>Create a static mechanical analysis for the given finite element model.</p><p><strong>Arguments</strong></p><ul><li><code>model::FEModel</code>: Finite element model definition.</li><li><code>outdir::String</code>: Directory for output files. Defaults to <code>&quot;./output&quot;</code>.</li><li><code>outkey::String</code>: Key prefix for output files. Defaults to <code>&quot;out&quot;</code>.</li></ul><p><strong>Behavior</strong></p><ul><li>Initializes an <code>AnalysisData</code> instance with the given output settings.</li><li>If <code>model.ctx.stress_state == :auto</code> and <code>model.ctx.ndim == 2</code>, the stress state is set to <code>:plane_strain</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = FEModel(mapper) # mapper is a RegionMapper with defined mappings
analysis = MechAnalysis(model; outdir=&quot;results&quot;, outkey=&quot;job1&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.MechBar"><a class="docstring-binding" href="#Serendip.MechBar"><code>Serendip.MechBar</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MechBar(; A)</code></pre><p>Mechanical formulation for axial bar elements.</p><p>This formulation defines uniaxial axial behavior along the element length. It is typically used for truss or rod elements in 1D, 2D, or 3D analyses.</p><p><strong>Parameters</strong></p><ul><li><code>A::Float64</code>: <em>Cross-sectional area</em> of the bar. Must be strictly positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.MechBondSlip"><a class="docstring-binding" href="#Serendip.MechBondSlip"><code>Serendip.MechBondSlip</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MechBondSlip(; p)</code></pre><p>Create a mechanical line-interface formulation for bond–slip between a rebar and surrounding material.</p><p><strong>Arguments</strong></p><ul><li><code>p::Real</code>: rebar perimeter (length).</li></ul><p><strong>Behavior</strong></p><ul><li>Pair with a bond–slip constitutive model.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>MechBondSlip</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.Mesh"><a class="docstring-binding" href="#Serendip.Mesh"><code>Serendip.Mesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Mesh(coordinates, connectivities, cellshapes=CellShape[]; tag=&quot;&quot;, quiet=true) -&gt; Mesh</code></pre><p>Construct a <code>Mesh</code> object directly from nodal coordinates and element connectivities.</p><p><strong>Arguments</strong></p><ul><li><code>coordinates::Matrix{&lt;:Real}</code>: Node coordinate matrix of size <code>(nnodes, ndim)</code>.</li><li><code>connectivities::Vector{Vector{Int}}</code>: Connectivity list, where each entry is a vector of node indices (1-based) defining an element.</li><li><code>cellshapes::Vector{CellShape}=CellShape[]</code>: Optional vector of element shapes (LIN2, QUAD4, etc.).   If not provided, shapes are inferred automatically from the number of nodes and spatial dimension.</li><li><code>tag::String=&quot;&quot;</code>: Optional tag applied to all created elements.</li><li><code>quiet::Bool=false</code>: If <code>true</code>, suppresses console output during construction.</li></ul><p><strong>Returns</strong></p><ul><li><code>mesh::Mesh</code>: A finite element mesh with nodes and elements created from the input data.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Serendip

# square domain with 4 points and 2 triangular elements
coordinates = [ 0.0 0.0;
                1.0 0.0;
                1.0 1.0;
                0.0 1.0 ]

connectivities = [ [1, 2, 3], [1, 3, 4] ]
cellshapes     = [ TRI3, TRI3 ]

mesh = Mesh(coordinates, connectivities, cellshapes; tag=&quot;tri&quot;)
println(mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.Mesh-Tuple{GeoModel}"><a class="docstring-binding" href="#Serendip.Mesh-Tuple{GeoModel}"><code>Serendip.Mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Mesh(geo::GeoModel; ndim=0, recombine=false, quadratic=false, algorithm=:delaunay,
     sort=true, quiet=false) -&gt; Mesh</code></pre><p>Generate a finite element mesh from a geometric model using Gmsh or structured blocks. Supports both <strong>unstructured</strong> meshing from OCC entities and <strong>structured</strong> meshing from <code>geo.blocks</code>. If both are present, unstructured meshing takes precedence.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing OCC entities and/or structured blocks.</li><li><code>ndim::Int=0</code>: Target mesh dimension (1, 2, or 3). Defaults to the maximum dimension present in the geometry.</li><li><code>recombine::Bool=false</code>: If <code>true</code>, recombines simplices (triangles, tetrahedra) into quads/hexas when possible.</li><li><code>quadratic::Bool=false</code>: If <code>true</code>, generates quadratic (second-order) elements.</li><li><code>algorithm::Symbol=:delaunay</code>: Meshing algorithm:<ul><li><code>:delaunay</code> → Delaunay (surface and 3D).</li><li><code>:mesh_adapt</code> → Adaptive meshing.</li><li><code>:best</code> → Frontal Delaunay (surface) + Delaunay (3D).</li><li><code>:frontal</code> → Frontal Delaunay (surface and 3D).</li></ul></li><li><code>sort::Bool=true</code>: If <code>true</code>, reorder mesh entities (nodes, elements) consistently after generation.</li><li><code>quiet::Bool=false</code>: If <code>true</code>, suppress console messages.</li></ul><p><strong>Behavior</strong></p><ul><li>Sets Gmsh meshing options according to algorithm and element order.</li><li>Defines physical groups for all top-dimensional entities.</li><li>Handles embedded points (<code>p.embedded == true</code>) by embedding them in host surfaces.</li><li>Removes orphan vertices without adjacencies.</li><li>Builds <code>Node</code> and <code>Cell</code> objects from Gmsh mesh data, including element connectivity.</li><li>For structured meshes uses block definitions from <code>geo</code>.</li><li>If <code>geo.gpaths</code> are present, generates insets and re-synchronizes.</li></ul><p><strong>Returns</strong></p><ul><li><code>mesh::Mesh</code>: A mesh object containing nodes, elements, faces, edges, and context information.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">geo = GeoModel()
# ... build OCC surfaces/volumes or add blocks ...
mesh = Mesh(geo; ndim=3, quadratic=true, algorithm=:frontal, sort=true)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.Mesh-Tuple{String}"><a class="docstring-binding" href="#Serendip.Mesh-Tuple{String}"><code>Serendip.Mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Mesh(filename::String; sort=false, quiet=true) -&gt; Mesh</code></pre><p>Load a finite element mesh from file. Supports VTK legacy (<code>.vtk</code>) and  VTK XML unstructured (<code>.vtu</code>) formats (preferred).</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: Path to the mesh file. Must have extension <code>.vtk</code> or <code>.vtu</code>.</li><li><code>sort::Bool=false</code>: If <code>true</code>, renumber nodes using a bandwidth-reduction algorithm after loading.</li><li><code>quiet::Bool=true</code>: If <code>true</code>, suppress console messages during loading.</li></ul><p><strong>Returns</strong></p><ul><li><code>mesh::Mesh</code>: Mesh object containing nodes, elements, faces and edges.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = Mesh(&quot;model.vtu&quot;; sort=true, quiet=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.MohrCoulombCohesive"><a class="docstring-binding" href="#Serendip.MohrCoulombCohesive"><code>Serendip.MohrCoulombCohesive</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MohrCoulombCohesive(; E, nu=0.0, ft, GF, wc, mu, psi=mu, ft_law=:hordijk, zeta=5.0)</code></pre><p>Constitutive model for cohesive elements with a Mohr–Coulomb strength criterion. The tensile branch is regularized with the bulk characteristic length <code>h</code> to ensure mesh-objective dissipation. Normal and shear interface stiffnesses are derived from <code>E</code>, <code>nu</code>, <code>zeta</code>, and <code>h</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>E::Real</code> Young’s modulus of the bulk material (&gt; 0).</li><li><code>nu::Real</code> Poisson’s ratio (0 ≤ ν &lt; 0.5).</li><li><code>ft::Real</code> Tensile strength (&gt; 0).</li><li><code>wc::Real</code> Critical crack opening (&gt; 0 if provided). May be computed from <code>GF</code>.</li><li><code>GF::Real</code> Mode-I fracture energy (&gt; 0 if provided). May be used to compute <code>wc</code>.</li><li><code>mu::Real</code> Friction coefficient (&gt; 0).</li><li><code>ψ::Real</code> Dilarancy coefficient (&gt; 0)</li><li><code>ft_law::Union{Symbol,AbstractSpline} = :hordijk</code> Tensile softening law. Symbols: <code>:linear</code>, <code>:bilinear</code>, <code>:hordijk</code>; or a custom Spline.</li><li><code>zeta::Real = 5.0</code> Dimensionless factor controlling elastic relative displacements (≥ 0).</li></ul><p><strong>Returns</strong></p><p>A <code>MohrCoulombCohesive</code> object.</p><p><strong>Notes</strong></p><ul><li>Provide either <code>wc</code> or <code>GF</code>. If only <code>GF</code> is given, <code>wc</code> is computed from <code>ft_law</code>.</li><li>Frictional strength is governed by <code>mu</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.MohrCoulombContact"><a class="docstring-binding" href="#Serendip.MohrCoulombContact"><code>Serendip.MohrCoulombContact</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MohrCoulombContact(; ft, wc, GF, mu, kn, ks, ft_law=:hordijk)</code></pre><p>Constitutive model for interface/contact elements with a Mohr–Coulomb strength criterion. It combines normal and shear stiffness, tensile strength, friction, and a post-peak tensile softening law defined either by the critical crack opening <code>wc</code> or by the fracture energy <code>GF</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>ft::Real</code> Tensile strength (≥ 0).</li><li><code>mu::Real</code> Friction coefficient (&gt; 0).</li><li><code>kn::Real</code> Normal stiffness per unit area (&gt; 0).</li><li><code>ks::Real</code> Shear stiffness per unit area (&gt; 0).</li><li><code>wc::Real</code> Critical crack opening (&gt; 0 if provided). May be computed from <code>GF</code>.</li><li><code>GF::Real</code> Mode-I fracture energy (&gt; 0 if provided). May be used to compute <code>wc</code>.</li><li><code>ft_law::Union{Symbol,AbstractSpline} = :hordijk</code> Tensile softening law. Use a symbol <code>:linear</code>, <code>:bilinear</code>, or <code>:hordijk</code>, or pass a Spline.</li></ul><p><strong>Returns</strong></p><p>An <code>MohrCoulombContact</code> object.</p><p><strong>Notes</strong></p><ul><li>Provide either <code>wc</code> or <code>GF</code>. If only <code>GF</code> is given, <code>wc</code> is computed based on <code>ft_law</code>.</li><li><code>kn</code> and <code>ks</code> control the elastic response before reaching the strength envelope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.PowerExpBondSlip"><a class="docstring-binding" href="#Serendip.PowerExpBondSlip"><code>Serendip.PowerExpBondSlip</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PowerExpBondSlip(; taumax, taures=0.0, speak, sc=20*speak, alpha=0.5, ks=taumax/speak, kn=100*ks)</code></pre><p>Construct an exponential decay bond–slip material model.</p><p><strong>Arguments</strong></p><ul><li><code>taumax</code>: Peak bond stress τmax (must be positive).</li><li><code>taures=0.0</code>: Residual bond stress τres (non-negative, ≤ τmax).</li><li><code>speak</code>: Slip at which τmax is reached.</li><li><code>sc=20*speak</code>: Critical slip where softening branch tend to stabilize.</li><li><code>alpha=0.5</code>: Shape parameter controlling decay (must lie in (0,1)).</li><li><code>ks=taumax/speak</code>: Tangential stiffness in slip direction (defaults to τmax/speak).</li><li><code>kn=100*ks</code>: Normal stiffness (defaults to 100·ks).</li></ul><p><strong>Returns</strong></p><ul><li><code>PowerExpBondSlip</code>: A material instance representing the exponential decay bond–slip law.</li></ul><p><strong>Notes</strong></p><ul><li>Checks enforce positivity of parameters and ordering <code>τmax ≥ τres</code>.</li><li>Suitable for bond–slip interface modeling with exponential decay to residual strength.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.PowerYieldCohesive"><a class="docstring-binding" href="#Serendip.PowerYieldCohesive"><code>Serendip.PowerYieldCohesive</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PowerYieldCohesive(; E, nu=0.0, ft, fc, zeta=5.0, wc, GF, ft_law=:hordijk, alpha=1.5, gamma=0.1, theta=1.5)</code></pre><p>Constitutive model for cohesive elements with a power-lay yield surface ans ft<em>law in tension.   The tensile ft</em>law branch is regularized through a measure of the bulk element size <code>h</code> to ensure mesh-objective fracture energy dissipation.</p><p><strong>Keyword arguments</strong></p><ul><li><code>E::Real</code>:   Young’s modulus from the bulk material (must be &gt; 0).</li><li><code>nu::Real</code>:   Poisson’s ratio (0 ≤ ν &lt; 0.5).</li><li><code>fc::Real</code>:   Compressive strength (&lt; 0).<ul><li><code>ft::Real</code>:  </li></ul>Tensile strength (&gt; 0).</li><li><code>wc::Real</code>:   Critical crack opening (must be &gt; 0 if given). Can be specified alternatively to <code>GF</code>.</li><li><code>mu::Real</code>:   Friction coefficient (&gt; 0).</li><li><code>GF::Real</code>:   Fracture energy (must be &gt; 0 if given). Can be specified alternatively to <code>wc</code>.</li><li><code>ft_law::Union{Symbol,AbstractSpline} = :hordijk</code>:   Softening law for post-peak tensile response. Options are: <code>:linear</code>, <code>:bilinear</code>, <code>:hordijk</code>, <code>:soft</code> or a custom function.</li><li><code>alpha::Real = 1.5</code>:   Parameter to control the shape of the yield surface (α &gt; 0.5).</li><li><code>gamma::Real = 0.1</code>:   Parameter to control the residual shear strength (γ ≥ 0).</li><li><code>theta::Real = 1.5</code>:   Parameter to control the rate of reduction of shear strength (θ ≥ 0).</li><li><code>zeta::Real = 5.0</code>:   Factor to control elastic relative displacements in cohesive formulations (≥ 0).</li></ul><p><strong>Returns</strong></p><p>A <code>PowerYieldCohesive</code> object.</p><p><strong>Notes</strong></p><ul><li>Either <code>wc</code> or <code>GF</code> must be provided. If only <code>GF</code> is given, <code>wc</code> is computed internally based on the chosen ft_law law.</li><li>The frictional contribution is governed by <code>mu</code>.</li><li>Normal and shear stiffnesses (<code>kn</code>, <code>ks</code>) are computed from the mechanical properties of the bulk material and the characteristic length <code>h</code> of the adjacent bulk elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.RegionMapper"><a class="docstring-binding" href="#Serendip.RegionMapper"><code>Serendip.RegionMapper</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RegionMapper()</code></pre><p>Creates an empty <code>RegionMapper</code> object.</p><p>A <code>RegionMapper</code> holds a list of region mappings that associate parts of the mesh (defined by filters) with element formulations, constitutive models, and their parameters. Mappings can later be added using <a href="#Serendip.add_mapping-Union{Tuple{S}, Tuple{T}, Tuple{RegionMapper, Any, Type{S}, Type{T}}} where {T&lt;:Constitutive, S&lt;:Serendip.ElementFormulation}"><code>add_mapping</code></a>.</p><p>Each mapping associates a filtered region of the mesh with:</p><ul><li>An element formulation (<code>etype</code>),</li><li>A constitutive model (<code>cmodel</code>),</li><li>A list of parameter values (<code>params</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.SolverSettings-Tuple{}"><a class="docstring-binding" href="#Serendip.SolverSettings-Tuple{}"><code>Serendip.SolverSettings</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SolverSettings(; tol=0.01, rtol=0.01, dT0=0.01, dTmin=1e-7, dTmax=0.1,
                  rspan=0.01, tangent_scheme=:forward_euler, maxits=15, autoinc=false, quiet=false)</code></pre><p>Defines configuration parameters for controlling the analysis process.</p><p><strong>Arguments</strong></p><ul><li><code>tol::Float64</code>: Absolute tolerance for convergence checks.</li><li><code>rtol::Float64</code>: Relative tolerance for convergence checks.</li><li><code>autoinc::Bool</code>: Enable automatic increment control .</li><li><code>dT0::Float64</code>: Initial increment of pseudo-time.</li><li><code>dTmin::Float64</code>: Minimum allowed increment of pseudo-time.</li><li><code>dTmax::Float64</code>: Maximum allowed increment of pseudo-time.</li><li><code>tangent_scheme::Symbol</code>: Tangent update approach (<code>:forward_euler</code>, <code>:heun</code>, <code>:ralston</code>, <code>:backward_euler</code>).</li><li><code>maxits::Int</code>: Maximum number of iterations per increment .</li><li><code>rspan::Float64</code>: Progression span for reapplying the residual in nonlinear iterations.</li><li><code>alpha::Float64</code>: Damping coefficient for the mass matrix used in dynamic analyses.</li><li><code>beta::Float64</code>: Damping coefficient for the stiffness matrix used in dynamic analyses.</li><li><code>nmodes::Int</code>: Number of modes to compute in modal analysis .</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">settings = SolverSettings(tol=1e-4, rtol=1e-3, autoinc=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.UCP"><a class="docstring-binding" href="#Serendip.UCP"><code>Serendip.UCP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UCP(; E, nu, fc, epsc, eta=4, ft, GF, wc, p0, alpha=0.666, beta=1.15, H=0.0)</code></pre><p>Unified Concrete Plasticity model.</p><p>This constitutive model defines a three-invariant plasticity surface for concrete, with a closed cap in compression and fracture-energy regularization in tension. It combines elastic isotropy, nonlinear hardening/softening in compression, and tension softening controlled by the fracture energy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>E::Real</code>:   Young’s modulus (must be &gt; 0).</li><li><code>nu::Real</code>:   Poisson’s ratio (0 ≤ ν &lt; 0.5).</li><li><code>fc::Real</code>:   Uniaxial compressive strength (&lt; 0).</li><li><code>epsc::Real</code>:   Strain at the compressive peak (&lt; 0).</li><li><code>eta::Real = 2.2</code>:   Shape parameter for the compression hardening/softening curve (eta &gt; 1).</li><li><code>ft::Real</code>:   Uniaxial tensile strength (&gt; 0).</li><li><code>GF::Real</code>:   Tensile fracture energy (&gt; 0). Can be given alternatively to <code>wc</code>.</li><li><code>wc::Real</code>:   Critical crack opening displacement (≥ 0). Can be given alternatively to <code>GF</code>.</li><li><code>p0::Real = NaN</code>:   Elastic limit in isotropic compression. If not given, computed internally from <code>fc</code> and <code>beta</code>.</li><li><code>alpha::Real = 0.666</code>:   Shape parameter of the meridional section (0.2 &lt; α ≤ 1.0).</li><li><code>beta::Real = 1.15</code>:   Factor relating biaxial to uniaxial compressive strength (1 ≤ β ≤ 1.5).</li><li><code>H::Real = 0.0</code>:   Plastic modulus for isotropic compression (≥ 0).</li></ul><p><strong>Returns</strong></p><p>A <code>UCP</code> material object that can be attached to mechanical bulk elements for 2D (plane strain) or 3D analyses. Not compatible with plane stress.</p><p><strong>Notes</strong></p><ul><li>The tensile law is regularized through <code>GF</code> and <code>wc</code> to ensure energy dissipation is independent of element size.</li><li>The compressive response follows a nonlinear curve defined by <code>fc</code>, <code>epsc</code>, and <code>eta</code>.</li><li>The cap position is adjusted by <code>beta</code> and <code>p0</code>.</li><li>The surface excentricity is computed internally to match the biaxial strength.</li><li>The surface section follows the Willam-Warnke ellipsoidal shape.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.VonMises"><a class="docstring-binding" href="#Serendip.VonMises"><code>Serendip.VonMises</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VonMises(; E, nu=0.0, fy, H=0.0)</code></pre><p>Linear-elastic constitutive model with Von Mises yield criterion and linear isotropic hardening. Implements J2 (pressure-insensitive) plasticity with associated flow rule.</p><p><strong>Arguments</strong></p><ul><li><code>E::Float64</code>: Young’s modulus (must be &gt; 0.0).</li><li><code>nu::Float64</code>: Poisson’s ratio (0.0 ≤ ν &lt; 0.5).</li><li><code>fy::Float64</code>: Initial yield stress (must be &gt; 0.0).</li><li><code>H::Float64</code>: Hardening modulus (≥ 0.0). A value of 0.0 corresponds to perfect plasticity.</li></ul><p><strong>State Variables</strong></p><p>Stored in <code>VonMisesState</code> (and its variants for reduced kinematics):</p><ul><li><code>σ</code>: Stress tensor (full <code>Vec6</code> for 3D, reduced forms for plane stress, beam, and bar).</li><li><code>ε</code>: Strain tensor (same format as <code>σ</code>).</li><li><code>εpa::Float64</code>: Accumulated plastic strain.</li><li><code>Δλ::Float64</code>: Plastic multiplier increment.</li></ul><p><strong>Variants</strong></p><ul><li><code>VonMisesState</code>: 3D continuum elements (full stress/strain in Voigt notation).</li><li><code>VonMisesPlaneStressState</code>: Plane stress elements.</li><li><code>VonMisesBeamState</code>: Beam elements (axial + bending stress/strain).</li><li><code>VonMisesBarState</code>: Truss elements (uniaxial stress/strain).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.WillamWarnke"><a class="docstring-binding" href="#Serendip.WillamWarnke"><code>Serendip.WillamWarnke</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WillamWarnke(; E, nu, fc, epsc, η=2.2, ft, GF=NaN, wc=NaN,
              ft_law=:hordijk, fc_law=:popovics, beta=1.15)</code></pre><p>Linear‐elastic concrete with a Willam–Warnke yield surface and nonlinear hardening/softening in compression and tension softening regularized by fracture energy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>E::Real</code>: Young’s modulus (&gt; 0).</li><li><code>nu::Real</code>: Poisson’s ratio (0 ≤ ν &lt; 0.5).</li><li><code>fc::Real</code>: Uniaxial compressive strength (&lt; 0).</li><li><code>epsc::Real</code>: Strain at the compressive peak (&lt; 0).</li><li><code>η::Real=2.2</code>: Shape parameter for the compressive curve (&gt; 1).</li><li><code>ft::Real</code>: Uniaxial tensile strength (&gt; 0).</li><li><code>GF::Real=NaN</code>: Tensile fracture energy (&gt; 0). Use <code>GF</code> or <code>wc</code>.</li><li><code>wc::Real=NaN</code>: Critical crack opening (≥ 0). Use <code>wc</code> or <code>GF</code>.</li><li><code>ft_law::Symbol=:hordijk</code>: Tension softening law. <code>:hordijk</code> uses the Hordijk curve.</li><li><code>fc_law::Symbol=:popovics</code>: Compression law. <code>:popovics</code> uses a Popovics-type curve.</li><li><code>beta::Real=1.15</code>: Biaxial/uniaxial compressive strength factor (1 ≤ β ≤ 1.5).</li></ul><p>Exactly one of <code>GF</code> or <code>wc</code> must be provided.</p><p><strong>Returns</strong></p><p>A <code>WillamWarnke</code> material usable with 3D or plane-strain bulk elements. Not compatible with plane stress.</p><p><strong>Notes</strong></p><ul><li>Tension softening is regularized by <code>GF</code> or <code>wc</code> to keep energy dissipation mesh-objective.</li><li>Compression response follows the selected <code>fc_law</code> shaped by <code>(fc, epsc, η)</code>.</li><li><code>beta</code> sets <code>fb = β·fc</code> internally.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mat = WillamWarnke(E=30e9, nu=0.2, fc=-30e6, epsc=-0.002, ft=3e6,
                   GF=120.0, ft_law=:hordijk, fc_law=:popovics, beta=1.15)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Tuple{GeoModel, Serendip.GeoEntity}"><a class="docstring-binding" href="#Base.copy-Tuple{GeoModel, Serendip.GeoEntity}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copy(geo, ent::GeoEntity)</code></pre><p>Copy a single geometric entity in the geometry model <code>geo</code>.</p><p><strong>Returns</strong></p><ul><li><code>GeoEntity</code>: The copied entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Tuple{GeoModel, Vector{&lt;:Serendip.GeoEntity}}"><a class="docstring-binding" href="#Base.copy-Tuple{GeoModel, Vector{&lt;:Serendip.GeoEntity}}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copy(geo, ents::Vector{&lt;:GeoEntity})</code></pre><p>Copy a list of geometric entities in the geometry model <code>geo</code>. Synchronizes OCC before and after copying.</p><p><strong>Returns</strong></p><ul><li><code>Vector{GeoEntity}</code>: The copied entities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.filter-Tuple{DataTable, Expr}"><a class="docstring-binding" href="#Base.filter-Tuple{DataTable, Expr}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filter(table::DataTable, expr::Expr)</code></pre><p>Filter rows of a DataTable object using a logical expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.intersect-Tuple{GeoModel, Any, Any}"><a class="docstring-binding" href="#Base.intersect-Tuple{GeoModel, Any, Any}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intersect(geo, ents1, ents2; remove_object=true, tag=&quot;&quot;)</code></pre><p>Boolean intersection of <code>ents1</code> and <code>ents2</code> in the geometric model <code>geo</code>.   All entities in each set must have the same topological dimension.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the operation occurs.</li><li><code>ents1</code>: First set of entities (same dimension).</li><li><code>ents2</code>: Second set of entities (same dimension).</li><li><code>remove_object::Bool=true</code>: If <code>true</code>, remove original inputs.</li><li><code>tag::String=&quot;&quot;</code>: If non-empty, assigns this tag to all resulting entities.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Resulting intersection entities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.run-Tuple{Serendip.Analysis}"><a class="docstring-binding" href="#Base.run-Tuple{Serendip.Analysis}"><code>Base.run</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run(ana;
    tol=0.01, rtol=0.01, autoinc=false,
    dT0=0.01, dTmin=1e-7, dTmax=0.1, rspan=0.01,
    tangent_scheme=:forward_euler, maxits=5,
    alpha=0.0, beta=0.0, nmodes=5, rayleigh=false,
    quiet=false)</code></pre><p>Execute a finite-element analysis and return the solver status.</p><p><strong>Arguments</strong></p><ul><li><code>ana::Analysis</code>: analysis object to solve.</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Real</code>: absolute convergence tolerance for the residual.</li><li><code>rtol::Real</code>: relative convergence tolerance for the residual.</li><li><code>autoinc::Bool</code>: enable automatic step size control.</li><li><code>dT0::Real</code>: initial time/load increment.</li><li><code>dTmin::Real</code>: minimum allowed increment.</li><li><code>dTmax::Real</code>: maximum allowed increment.</li><li><code>rspan::Real</code>: span parameter for the auto-increment controller.</li><li><code>tangent_scheme::Symbol</code>: global tangent computation approach (<code>:forward_euler</code>, <code>:heun</code>, <code>:ralston</code>).</li><li><code>maxits::Int</code>: maximum nonlinear iterations per step.</li><li><code>alpha::Float64</code>: Mass matrix coefficient to compute damping in dynamic analyses.</li><li><code>beta::Float64</code>: Stiffness matrix coefficient to compute damping in dynamic analyses.</li><li><code>nmodes::Int</code>: number of modes in modal analysis.</li><li><code>rayleigh::Bool</code>: enable Rayleigh damping.</li><li><code>quiet::Bool</code>: suppress console output.</li></ul><p><strong>Behavior</strong></p><ul><li>Prints a short banner with analysis type, stress model, scheme, and active threads unless <code>quiet=true</code>.</li><li>Builds <code>SolverSettings</code> from the provided keywords and advances stages via <code>stage_iterator</code>.</li></ul><p><strong>Returns</strong></p><ul><li>Solver status object returned by <code>stage_iterator</code> (implementation-specific).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">status = run(analysis;
             tol=1e-3, rtol=1e-3, autoinc=true,
             dT0=0.02, dTmin=1e-6, dTmax=0.1,
             tangent_scheme=:rk2, maxits=10, alpha=0.0, beta=0.25,
             nmodes=8, rayleigh=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.RegionModel-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, Type{T}}} where {T&lt;:Constitutive, S&lt;:Serendip.ElementFormulation}"><a class="docstring-binding" href="#Serendip.RegionModel-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, Type{T}}} where {T&lt;:Constitutive, S&lt;:Serendip.ElementFormulation}"><code>Serendip.RegionModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RegionModel(etype, cmodel; params...)</code></pre><p>Creates a <code>RegionMapper</code> for simple cases where the <strong>same element formulation</strong> and <strong>constitutive model</strong> are applied to the entire mesh.</p><p>This is a convenience shortcut equivalent to manually creating a <code>RegionMapper</code> and adding a mapping with <code>selector=:all</code>.</p><p><strong>Arguments</strong></p><ul><li><code>etype::Type</code>: The element formulation type (e.g., <code>MechBulk</code>).</li><li><code>cmodel::Type</code>: The constitutive model type (e.g., <code>LinearElastic</code>).</li><li><code>params...</code>: Named parameters for the constitutive model.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = RegionModel(MechBulk, LinearElastic; rho=10, E=1.0, nu=0.3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_array-Tuple{GeoModel, GPath}"><a class="docstring-binding" href="#Serendip.add_array-Tuple{GeoModel, GPath}"><code>Serendip.add_array</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_array(geometry, path; nx=1, ny=1, nz=1, dx=0.0, dy=0.0, dz=0.0)</code></pre><p>Creates a regular array of copies of a given <code>GPath</code> and adds them to the model.</p><p><strong>Arguments</strong></p><ul><li><code>geometry::GeoModel</code>: Target geometric model.</li><li><code>gpath::GPath</code>: The original path to replicate.</li><li><code>nx, ny, nz</code>: Number of copies in each spatial direction.</li><li><code>dx, dy, dz</code>: Spacing between copies in each direction.</li></ul><p>The original path is keeped in the model as part of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_bc-Tuple{Stage, Symbol, Any}"><a class="docstring-binding" href="#Serendip.add_bc-Tuple{Stage, Symbol, Any}"><code>Serendip.add_bc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_bc(stage::Stage, kind::Symbol, selector; conds...)</code></pre><p>Add a boundary condition (BC) to the given <code>stage</code> in the analysis.</p><p>This function attaches a boundary condition to a specific set of entities in the model, identified by <code>kind</code> and filtered using a spatial expression or coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>stage::Stage</code>: The analysis stage where the boundary condition will be applied.</li><li><code>kind::Symbol</code>: The type of boundary entity to apply the condition on. Options:<ul><li><code>:node</code> – apply on nodes.</li><li><code>:face</code> – apply on faces (in 3D) or edges (in 2D).</li><li><code>:edge</code> – apply on edges explicitly.</li></ul></li><li><code>selector</code>: A filtering expression or array of coordinates to select entities for the BC. If a coordinate array is provided for <code>:node</code>, it is converted into an equality selector.</li><li><code>conds...</code>: Named keyword arguments specifying the boundary conditions to apply (e.g., <code>ux=0</code>, <code>uy=0</code>, <code>tz=-5</code>).</li></ul><p><strong>Behavior</strong></p><ul><li>Resolves the target entities (<code>nodes</code>, <code>faces</code>, or <code>edges</code>) in the finite element model using the provided <code>selector</code>.</li><li>If <code>kind == :face</code> in a 2D model, surface BCs are automatically mapped to edges with a notification.</li><li>Adds the resulting <code>BoundaryCondition</code> to <code>stage.bcs</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>bc::BoundaryCondition</code>: The created boundary condition object.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">add_bc(stage, :node, x==0, ux=0, uy=0)      # Fix displacement on nodes at x==0
add_bc(stage, :face, z==1, tz=-10)       # Apply surface traction at z==1
add_bc(stage, :edge, (y==0,z==1), qx=10)    # Apply linear traction at edges where y==0 &amp;&amp; z==1
add_bc(stage, :node, [0.0, 0.0, 0.0], ux=0) # Constrain node at origin</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_block-Tuple{GeoModel, Any, Real, Real, Real}"><a class="docstring-binding" href="#Serendip.add_block-Tuple{GeoModel, Any, Real, Real, Real}"><code>Serendip.add_block</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_block(geometry, X1, X2;
    nx=0, ny=0, nz=0, n=0,
    rx=1.0, ry=1.0, rz=1.0, r=0.0,
    shape=nothing, tag=&quot;&quot;)</code></pre><p>Adds a 1D, 2D or 3D block (<code>Block</code>) to the geometric model using two opposite corner points.</p><p><strong>Arguments</strong></p><ul><li><code>geometry::GeoModel</code>: Target geometric model to which the block is appended.</li><li><code>X1::Vector{&lt;:Real}</code>: Coordinates of the first corner (lower vertex).</li><li><code>X2::Vector{&lt;:Real}</code>: Coordinates of the opposite corner (upper vertex).</li><li><code>nx::Int=1, ny::Int=0, nz::Int=0</code>: Number of mesh divisions along x, y, and z.</li><li><code>n::Int=0</code>: Number of mesh divisions for 1D blocks (overrides <code>nx</code>).</li><li><code>rx::Real=1.0, ry::Real=1.0, rz::Real=1.0</code>: Element size grading ratios along x, y, and z.</li><li><code>r::Real=0.0</code>: Element size grading ratio for 1D blocks (overrides <code>rx</code>).</li><li><code>shape</code>: Optional finite element cell type (<code>HEX8</code>, <code>HEX20</code>, <code>QUAD4</code>, <code>LIN2</code>, etc.).   If omitted, it is inferred from the number of points and dimension.</li><li><code>tag::String=&quot;&quot;</code>: Optional tag identifier for the block.</li></ul><p><strong>Behavior</strong></p><ul><li>The block dimension (<code>ndim</code>) is inferred from the number of nonzero coordinate components:<ul><li>1D → line block (<code>LIN2</code>, <code>LIN3</code>)</li><li>2D → surface block (<code>QUAD4</code>, <code>QUAD8</code>)</li><li>3D → volume block (<code>HEX8</code>, <code>HEX20</code>)</li></ul></li><li>The <code>shape</code> argument must match the inferred dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>Block</code>: The block object appended to <code>geometry.blocks</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">geo = GeoModel()

# Define opposite corners of a 3D domain
X1 = [0.0, 0.0, 0.0]
X2 = [2.0, 1.0, 1.0]

# Add a hexahedral block with graded mesh along z
blk = add_block(geo, X1, X2;
nx=8, ny=4, nz=4, rz=1.3,
shape=HEX8,
tag=&quot;foundation&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_boundary_contact_elements"><a class="docstring-binding" href="#Serendip.add_boundary_contact_elements"><code>Serendip.add_boundary_contact_elements</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_boundary_contact_elements(mesh, selector; tag=&quot;&quot;, nodes_tag=&quot;&quot;, quiet=false)</code></pre><p>Add contact interface elements to the boundary of <code>mesh</code>, coupling the original boundary faces with duplicated support nodes. Useful for modeling surface contact or elastic supports (e.g., Winkler foundation).</p><p>Idempotency: This function generates the new contact elements first, then checks the existing mesh  to remove any old contact elements that match the <strong>Owner</strong> (Topology) and  <strong>Location</strong> (Geometry) of the new elements. This safely handles updates without  duplicating elements.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::Mesh</code>: The mesh where boundary contact elements will be added.</li><li><code>selector</code>: Region selector (e.g. &quot;bottom_face&quot;).</li><li><code>tag::String=&quot;&quot;</code>: Tag for generated contact elements.</li><li><code>nodes_tag::String=&quot;&quot;</code>: Tag for the duplicated support nodes.</li><li><code>quiet::Bool=false</code>: Suppress output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_boundary_shell_elements-Tuple{Mesh, Union{Expr, String, Tuple, Symbolic}}"><a class="docstring-binding" href="#Serendip.add_boundary_shell_elements-Tuple{Mesh, Union{Expr, String, Tuple, Symbolic}}"><code>Serendip.add_boundary_shell_elements</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_boundary_shell_elements(mesh, selector; tag=&quot;&quot;, contact_tag=&quot;&quot;, quiet=false)</code></pre><p>Add shell (surface) elements to the boundary of <code>mesh</code>, optionally coupling them with contact interface elements.</p><p>Idempotency: This function generates the new boundary elements first, then checks the existing mesh  to remove any old shell/contact elements that match the <strong>Owner</strong> (Topology) and  <strong>Location</strong> (Geometry) of the new faces. This safely handles updates without  duplicating elements or accidentally deleting neighbors across a crack.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::Mesh</code>: The mesh where shell elements will be added.</li><li><code>selector::Union{Expr,Symbolic,Tuple,String}</code>: Region selector defining which boundary faces are converted to shells.</li><li><code>tag::String=&quot;&quot;</code>: Tag assigned to the created shell elements.</li><li><code>contact_tag::String=&quot;&quot;</code>: If provided, also create contact elements linking original faces and new shell nodes, tagged with this value.</li><li><code>quiet::Bool=false</code>: Suppress console output if <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Mesh</code>: The updated mesh including the new shell and, if applicable, contact elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_box-Tuple{GeoModel, Vector{&lt;:Real}, Real, Real, Real}"><a class="docstring-binding" href="#Serendip.add_box-Tuple{GeoModel, Vector{&lt;:Real}, Real, Real, Real}"><code>Serendip.add_box</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_box(geo, X, dx, dy, dz; tag=&quot;&quot;)</code></pre><p>Create a box volume in the geometric model <code>geo</code>, starting at corner <code>X</code> with dimensions <code>dx</code>, <code>dy</code>, and <code>dz</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the box will be added.</li><li><code>X::Vector{&lt;:Real}</code>: Corner coordinates <code>[x, y, z]</code>.</li><li><code>dx::Real</code>: Box size along the x-direction.</li><li><code>dy::Real</code>: Box size along the y-direction.</li><li><code>dz::Real</code>: Box size along the z-direction.</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the volume.</li></ul><p><strong>Returns</strong></p><ul><li><code>Volume</code>: The created box entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_circle-Tuple{GeoModel, Vector{&lt;:Real}, Vector{&lt;:Real}, Any}"><a class="docstring-binding" href="#Serendip.add_circle-Tuple{GeoModel, Vector{&lt;:Real}, Vector{&lt;:Real}, Any}"><code>Serendip.add_circle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_circle(geo, X, A, r; angle1=0.0, angle2=2π, tag=&quot;&quot;)</code></pre><p>Add a circular curve to the geometric model <code>geo</code>, centered at <code>X</code> with normal vector <code>A</code> and radius <code>r</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the circle will be added.</li><li><code>X::Vector{&lt;:Real}</code>: Center coordinates <code>[x, y, z]</code>.</li><li><code>A::Vector{&lt;:Real}</code>: Normal vector to the circle plane.</li><li><code>r::Real</code>: Circle radius.</li><li><code>angle1::Real=0.0</code>: Starting angle in radians.</li><li><code>angle2::Real=2π</code>: Ending angle in radians.</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the circle.</li></ul><p><strong>Returns</strong></p><ul><li><code>Edge</code>: The created circle entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_circle_arc-Tuple{GeoModel, Point, Point, Point}"><a class="docstring-binding" href="#Serendip.add_circle_arc-Tuple{GeoModel, Point, Point, Point}"><code>Serendip.add_circle_arc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_circle_arc(geo, p1, p2, p3; center=true, tag=&quot;&quot;)</code></pre><p>Add a circular arc to the geometric model <code>geo</code>, with points <code>p1</code>, <code>p2</code>, and <code>p3</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the arc will be added.</li><li><code>p1::Point</code>: Starting point of the arc.</li><li><code>p2::Point</code>: Intermediate point or circle center, depending on <code>center</code>.</li><li><code>p3::Point</code>: Ending point of the arc.</li><li><code>center::Bool=true</code>: If <code>true</code>, <code>p2</code> is treated as the circle center; otherwise, it is a point on the arc.</li><li><code>tag::String=&quot;&quot;</code>: Optional identifier for the arc.</li></ul><p><strong>Returns</strong></p><ul><li><code>Edge</code>: The created arc entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_cohesive_elements"><a class="docstring-binding" href="#Serendip.add_cohesive_elements"><code>Serendip.add_cohesive_elements</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_cohesive_elements(mesh, selector=nothing; tag=&quot;&quot;, implicit=false, quiet=false)</code></pre><p>Insert cohesive elements into <code>mesh</code> by pairing coincident faces. Prevents insertion if the interface is already occupied by a contact element.</p><p>Algorithm:</p><ol><li>Split elements into target (where interfaces are searched) and locked (kept as-is).</li><li>Optionally duplicate target-cell nodes (<code>implicit=false</code>) to make interfaces topologically open.</li><li>Build a geometric index of existing contact interfaces to avoid overlap.</li><li>Pair coincident faces from target and neighboring locked boundaries.</li><li>Create cohesive elements with aligned node ordering across both faces.</li><li>Remove old cohesive elements that match the same owners and interface geometry.</li></ol><p><strong>Arguments</strong></p><ul><li><code>mesh::Mesh</code>: Mesh to modify.</li><li><code>selector::Union{Expr,Symbol,Symbolic,Tuple,String,Nothing}=nothing</code>: Optional selector restricting where cohesive elements are created.</li><li><code>tag::String=&quot;&quot;</code>: Tag assigned to generated cohesive elements.</li><li><code>implicit::Bool=false</code>: If <code>true</code>, keeps the original shared topology (intrinsic/implicit interface activation). If <code>false</code>, duplicates target-region cell nodes before pairing faces so cohesive elements are created with distinct node sets on each side.</li><li><code>quiet::Bool=false</code>: Suppress output.</li></ul><p><strong>Returns</strong></p><ul><li><code>Mesh</code>: The updated mesh including the new cohesive elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_contact_elements-Tuple{Mesh, Vararg{Any}}"><a class="docstring-binding" href="#Serendip.add_contact_elements-Tuple{Mesh, Vararg{Any}}"><code>Serendip.add_contact_elements</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_contact_elements(mesh, selectors...; tag=&quot;&quot;, quiet=false)</code></pre><p>Inserts contact elements along interfaces between distinct regions. Simplifies the removal of conflicting cohesive elements by performing a post-generation check.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_cylinder"><a class="docstring-binding" href="#Serendip.add_cylinder"><code>Serendip.add_cylinder</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_cylinder(geo, X, A, r; angle=2π, tag=&quot;&quot;)</code></pre><p>Create a cylindrical volume in the geometric model <code>geo</code>, with base center <code>X</code>, axis vector <code>A</code>, radius <code>r</code>, and optional angular span <code>angle</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the cylinder will be added.</li><li><code>X::Vector{&lt;:Real}</code>: Base center coordinates <code>[x, y, z]</code>.</li><li><code>A::Vector{&lt;:Real}</code>: Axis vector defining cylinder height and direction.</li><li><code>r::Real</code>: Cylinder radius.</li><li><code>angle::Real=2π</code>: Angular extent of the cylinder in radians.</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the volume.</li></ul><p><strong>Returns</strong></p><ul><li><code>Volume</code>: The created cylindrical volume entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_disk"><a class="docstring-binding" href="#Serendip.add_disk"><code>Serendip.add_disk</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_disk(geo, X, A, r1, r2=0; tag=&quot;&quot;)</code></pre><p>Create a circular or elliptical surface in the geometric model <code>geo</code>, centered at <code>X</code>, oriented along the normal vector <code>A</code>, with radii <code>r1</code> and <code>r2</code>.   If <code>r2 == 0</code>, a circular disk is created.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the disk will be added.</li><li><code>X::Vector{&lt;:Real}</code>: Center coordinates <code>[x, y, z]</code>.</li><li><code>A::Vector{&lt;:Real}</code>: Normal vector defining the disk orientation.</li><li><code>r1::Real</code>: Major radius.</li><li><code>r2::Real=0</code>: Minor radius (defaults to <code>r1</code> if zero).</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the surface.</li></ul><p><strong>Returns</strong></p><ul><li><code>Surface</code>: The created disk entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_line"><a class="docstring-binding" href="#Serendip.add_line"><code>Serendip.add_line</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_line(geo, p1, p2; tag=&quot;&quot;)</code></pre><p>Add a straight line connecting points <code>p1</code> and <code>p2</code> to the geometric model <code>geo</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the line will be added.</li><li><code>p1::Point</code>: Starting point of the line.</li><li><code>p2::Point</code>: Ending point of the line.</li><li><code>tag::String=&quot;&quot;</code>: Optional identifier for the line.</li></ul><p><strong>Returns</strong></p><ul><li><code>Edge</code>: The created line entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_logger"><a class="docstring-binding" href="#Serendip.add_logger"><code>Serendip.add_logger</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_logger(ana::Analysis, kind::Symbol, selector::Any, filename::String = &quot;&quot;)</code></pre><p>Adds a logger to an analysis, allowing you to record data during simulation.</p><p><strong>Arguments</strong></p><ul><li><p><code>ana::Analysis</code>:   The analysis object to which the logger will be attached. The logger is stored in <code>ana.loggers</code>.</p></li><li><p><code>kind::Symbol</code>:   Specifies the type of logger to create. Valid options are:</p><ul><li><code>:node</code>: Logs data at a single node.</li><li><code>:ip</code>: Logs data at a single integration point.</li><li><code>:nodegroup</code>: Logs data for a group of nodes.</li><li><code>:ipgroup</code>: Logs data for a group of integration points.</li><li><code>:nodalreduce</code>: Logs aggregated data (e.g., sum or average) across selected nodes.</li></ul></li><li><p><code>selector::Any</code>:   Defines how to select the items to log. Can be:</p><ul><li>A <strong>vector</strong> <code>[x, y, z]</code> specifying coordinates (the nearest matching item will be used if no exact match is found).</li><li>A <strong>logical expression</strong> (e.g., <code>x &gt; 0</code>).</li><li>A <strong>predefined tag</strong> or list of items.</li></ul></li><li><p><code>filename::String</code> (optional):   Name of the file where the log will be saved. If not provided, the logger will use the default output directory in <code>ana.data.outdir</code>.   The file extension should be <code>.table</code>, <code>.table</code> or <code>.json</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li>A <code>Logger</code> object of type <code>Logger{Node}</code> or <code>Logger{Ip}</code> depending on <code>kind</code>. This logger is also pushed into <code>ana.loggers</code>.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>kind</code> is <code>:node</code> or <code>:ip</code> and the selector matches multiple items, only the <strong>first match</strong> will be logged.</li><li>For <code>:nodegroup</code> and <code>:ipgroup</code>, the selected items are automatically sorted based on coordinates.</li><li>If no items match the selector, a notification is displayed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_loop-Tuple{GeoModel, Vector{Edge}}"><a class="docstring-binding" href="#Serendip.add_loop-Tuple{GeoModel, Vector{Edge}}"><code>Serendip.add_loop</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_loop(geo, edges)</code></pre><p>Create a closed curve loop from the sequence of <code>edges</code>. Used to define surface boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the loop will be added.</li><li><code>edges::Vector{Edge}</code>: Ordered list of edges forming a closed loop.</li></ul><p><strong>Returns</strong></p><ul><li><code>Loop</code>: The created curve loop entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_mapping-Union{Tuple{S}, Tuple{T}, Tuple{RegionMapper, Any, Type{S}, Type{T}}} where {T&lt;:Constitutive, S&lt;:Serendip.ElementFormulation}"><a class="docstring-binding" href="#Serendip.add_mapping-Union{Tuple{S}, Tuple{T}, Tuple{RegionMapper, Any, Type{S}, Type{T}}} where {T&lt;:Constitutive, S&lt;:Serendip.ElementFormulation}"><code>Serendip.add_mapping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_mapping(mapper::RegionMapper, selector, etype, cmodel; params...)</code></pre><p>Adds a new region mapping to the given <code>RegionMapper</code>.</p><p>Each mapping associates a filtered region of the mesh with:</p><ul><li>An element formulation (<code>etype</code>),</li><li>A constitutive model (<code>cmodel</code>),</li><li>A list of parameter values (<code>params</code>).</li></ul><p><strong>Arguments</strong></p><ul><li><code>mapper::RegionMapper</code>: The mapper to add the region mapping to.</li><li><code>selector</code>: A filtering expression defining the mesh region (e.g., <code>x==0</code>, <code>:all</code>).</li><li><code>etype::Type</code>: The element formulation type (e.g., <code>MechBulk</code>).</li><li><code>cmodel::Type</code>: The constitutive model type (e.g., <code>LinearElastic</code>).</li><li><code>params...</code>: Named parameters for the constitutive model (e.g., <code>rho=10.0, E=30.0e6</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">add_mapping(mapper, x&gt;=0, MechBulk, LinearElastic; rho=10.0, E=30.0e6, nu=0.3)</code></pre><p><strong>Trows</strong></p><p>An error if a mapping with the same <code>selector</code> already exists in the mapper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_monitor"><a class="docstring-binding" href="#Serendip.add_monitor"><code>Serendip.add_monitor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_monitor(
    ana::Analysis,
    kind::Symbol,
    selector::Any,
    expr::Union{Symbol, Expr, Tuple, Array},
    filename::String = &quot;&quot;;
    stop::Union{Expr,Tuple,Array,Nothing} = nothing
)</code></pre><p>Adds a monitor to the analysis for observing quantities during the simulation. Monitors are used to evaluate expressions at selected nodes or integration points and optionally trigger stopping conditions.</p><p><strong>Positional Arguments</strong></p><ul><li><p><code>ana::Analysis</code>:   The analysis object to which the monitor will be attached. The monitor is stored in <code>ana.monitors</code>.</p></li><li><p><code>kind::Symbol</code>:   Specifies the type of monitor. Valid options are:</p><ul><li><code>:node</code>: Monitor a single node.</li><li><code>:ip</code>: Monitor a single integration point.</li><li><code>:nodegroup</code>: Monitor a group of nodes.</li><li><code>:ipgroup</code>: Monitor a group of integration points.</li><li><code>:nodalreduce</code>: Monitor reduced quantities across selected nodes.</li></ul></li><li><p><code>selector</code>:   Defines how to select the items to monitor. Can be:</p><ul><li>A <strong>vector</strong> <code>[x, y, z]</code> specifying coordinates (the nearest matching item will be used if no exact match is found).</li><li>A <strong>logical expression</strong> (e.g., <code>x &gt; 0 &amp;&amp; y &lt; 1</code>).</li><li>A predefined tag or list of items.</li></ul></li><li><p><code>expr</code>:   One or more expressions to monitor. Can be a single <code>Symbol</code> (e.g., <code>:ux</code>), or a collection (e.g., <code>[:ux, :uy]</code>, a tuple, or an array).</p></li><li><p><code>filename::String</code> (optional):   Name of the file where the monitor results will be saved. If a path is not   provided, the file is saved in the current directory.   The file extension should be <code>.table</code>, <code>.table</code> or <code>.json</code>.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>stop</code> (optional):   Defines stop conditions for the monitor. Can be:<ul><li>An condition (e.g., <code>:(ux &gt; 0.1)</code>).</li><li>A collection of conditions.</li></ul><strong>Note:</strong> Stop conditions are only supported for <code>:node</code> and <code>:ip</code> kinds.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Monitor</code> object of type <code>Monitor{Node}</code> or <code>Monitor{Ip}</code>, depending on <code>kind</code>. The monitor is also pushed into <code>ana.monitors</code>.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>kind</code> is <code>:node</code> or <code>:ip</code> and the selector matches multiple items, only the <strong>first match</strong> will be monitored.</li><li>For <code>:nodegroup</code> and <code>:ipgroup</code>, the selected items are sorted automatically by coordinate sum.</li><li>If no items match the selector, the nearest item is chosen and a notification is displayed.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Monitor displacement ux at a node at x=0 and y==0
add_monitor(ana, :node, (x==0,y==0), :ux, &quot;monitor_node_ux.dat&quot;)

# Monitor stress components at a group of integration points
add_monitor(ana, :ipgroup, z&gt;1.0, [:sxx, :syy], &quot;stress_ipgroup.dat&quot;)

# Monitor a node and stop analysis if ux &gt; 0.01 at that node
add_monitor(ana, :node, [0.0, 0.0, 0.0], :ux; stop=:(ux &gt; 0.01))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_path-Tuple{GeoModel, Vector{Edge}}"><a class="docstring-binding" href="#Serendip.add_path-Tuple{GeoModel, Vector{Edge}}"><code>Serendip.add_path</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_path(geometry, edges; embedded=false, shape=LIN3, tag=&quot;&quot;, interface_tag=&quot;&quot;, tip_tag=&quot;&quot;, tips=:none)</code></pre><p>Adds a logical path structure (<code>GPath</code>) to the geometric model from a sequence of connected <code>Edge</code> objects. This is useful for modeling discrete and embedded 1D elements such as reinforcement bars, drains, or inclusions.</p><p><strong>Arguments</strong></p><ul><li><code>geometry::GeoModel</code>: Target geometric model.</li><li><code>edges::Vector{Edge}</code>: Sequence of connected edges that define the path.</li><li><code>embedded::Bool=false</code>: Whether the path is embedded into a solid domain. If embedded is <code>false</code>, interface elements will be created.</li><li><code>shape::CellShape=LIN3</code>: Finite element shape for discretization of the path (LIN2 or LIN3).</li><li><code>tag::String=&quot;&quot;</code>: Identifier tag for the path.</li><li><code>interface_tag::String=&quot;&quot;</code>: Optional tag used for interface elements.</li><li><code>tip_tag::String=&quot;&quot;</code>: Optional tag for used for tip elements at endpoints.</li><li><code>tips::Symbol=:none</code>: Specifies which endpoint elements are generated (e.g., <code>:start</code>, <code>:end</code>, <code>:both</code>). If tips is <code>:none</code>, no tips elements are created.</li></ul><p><strong>Returns</strong></p><ul><li><code>GPath</code>: The path structure added to the model.</li></ul><p>Note: Original OCC edges are removed from the geometry after constructing the path.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">geo = GeoModel()
point1 = add_point(geo, [0,0,0])
point2 = add_point(geo, [1,0,0])
point3 = add_point(geo, [2,0,0])
edge1 = add_line(geo, p1, p2)
edge2 = add_line(geo, p2, p3)

path = add_path(geo, [edge1, edge2]; tag=&quot;reinforcement&quot;, interface_tag=&quot;contact&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_plane_surface-Tuple{GeoModel, Vararg{Serendip.Loop}}"><a class="docstring-binding" href="#Serendip.add_plane_surface-Tuple{GeoModel, Vararg{Serendip.Loop}}"><code>Serendip.add_plane_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_plane_surface(geo, loops...; tag=&quot;&quot;)</code></pre><p>Create a planar surface in the geometric model <code>geo</code>, bounded by one or more <code>loops</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the surface will be added.</li><li><code>loops::Loop...</code>: One outer loop and optionally inner loops (holes).</li><li><code>tag::String=&quot;&quot;</code>: Optional identifier for the surface.</li></ul><p><strong>Returns</strong></p><ul><li><code>Surface</code>: The created surface entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_polygon-Tuple{Any, Vector{Point}}"><a class="docstring-binding" href="#Serendip.add_polygon-Tuple{Any, Vector{Point}}"><code>Serendip.add_polygon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_polygon(geo, points; tag=&quot;&quot;)</code></pre><p>Create a planar polygonal surface in the geometric model <code>geo</code> from an ordered list of <code>points</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the polygon will be added.</li><li><code>points::Vector{Point}</code>: Ordered vertices of the polygon. Edges are created sequentially and closed automatically.</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the surface.</li></ul><p><strong>Returns</strong></p><ul><li><code>Surface</code>: The created polygonal surface entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_rectangle-Tuple{GeoModel, Vector{&lt;:Real}, Real, Real}"><a class="docstring-binding" href="#Serendip.add_rectangle-Tuple{GeoModel, Vector{&lt;:Real}, Real, Real}"><code>Serendip.add_rectangle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_rectangle(geo, X, dx, dy; tag=&quot;&quot;)</code></pre><p>Create a rectangular planar surface in the geometric model <code>geo</code>, starting at corner <code>X</code> with dimensions <code>dx</code> and <code>dy</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the rectangle will be added.</li><li><code>X::Vector{&lt;:Real}</code>: Corner coordinates <code>[x, y, z]</code>.</li><li><code>dx::Real</code>: Rectangle width along the x-direction.</li><li><code>dy::Real</code>: Rectangle height along the y-direction.</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the surface.</li></ul><p><strong>Returns</strong></p><ul><li><code>Surface</code>: The created rectangular surface entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_series-Tuple{Chart, Symbol, AbstractArray, AbstractArray}"><a class="docstring-binding" href="#Serendip.add_series-Tuple{Chart, Symbol, AbstractArray, AbstractArray}"><code>Serendip.add_series</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_series(chart::Chart, kind::Symbol, X::AbstractArray, Y::AbstractArray; kwargs...)
add_series(chart::Chart, X::AbstractArray, Y::AbstractArray; kwargs...)</code></pre><p>Append a <code>DataSeries</code> to <code>chart</code>. The second version uses <code>kind = :line</code>.</p><p><strong>Arguments</strong></p><ul><li><code>chart::Chart</code> : Target chart (mutated).</li><li><code>kind::Symbol</code> : Plot type: <code>:line</code>, <code>:scatter</code>, <code>:bar</code>.</li><li><code>X, Y::AbstractArray</code> : Data vectors.</li></ul><p><strong>Keyword options</strong></p><ul><li><code>line_style::Symbol = :solid</code> : Line style (e.g. <code>:solid</code>, <code>:dash</code>, ...).</li><li><code>dash::Vector{Float64} = Float64[]</code> : Custom dash pattern. If nonempty, overrides <code>line_style</code>.</li><li><code>color = :default</code> : Line/marker color. <code>:default</code> selects from the chart palette cyclically.</li><li><code>line_width::Float64 = 0.5</code> : Line width (&gt; 0).</li><li><code>mark::Symbol = :none</code> : Mark shape.</li><li><code>mark_size::Float64 = 2.5</code> : Mark size (&gt; 0).</li><li><code>mark_color = :white</code> : Mark fill color.</li><li><code>mark_stroke_color = :default</code> : Mark edge color (<code>:default</code> follows <code>color</code>).</li><li><code>label::AbstractString = &quot;&quot;</code> : Legend label.</li><li><code>tag::AbstractString = &quot;&quot;</code> : On-curve annotation text.</li><li><code>tag_location::Symbol = :top</code> : Relative location of tag (<code>:top</code>, <code>:bottom</code>, <code>:left</code>, <code>:right</code>).</li><li><code>tag_position::Float64 = 0.5</code> : Position along the curve in [0,1].</li><li><code>tag_alignment::Symbol = :horizontal</code> : Tag orientation (<code>:horizontal</code>, <code>:vertical</code>, <code>:parallel</code>).</li><li><code>bar_width::Float64 = 0.0</code> : Bar width in x-data units (<code>0</code> enables auto width).</li><li><code>bar_base::Float64 = 0.0</code> : Bar baseline in y-data units.</li><li><code>order::Int = 0</code> : Z-order. If <code>0</code>, an incremental order is assigned.</li></ul><p><strong>Returns</strong></p><ul><li>The series object.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ch = Chart(size=(300,200), xlabel=&quot;Time [s]&quot;, ylabel=&quot;Displacement [mm]&quot;,
           xlimits=[0.0,10.0], ylimits=[-5.0,5.0], legend=:bottom_right)

add_line(ch, 0:0.1:10, sin.(0:0.1:10); label=&quot;sin&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_sphere-Tuple{GeoModel, Vector{&lt;:Real}, Real}"><a class="docstring-binding" href="#Serendip.add_sphere-Tuple{GeoModel, Vector{&lt;:Real}, Real}"><code>Serendip.add_sphere</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_sphere(geo, X, r; tag=&quot;&quot;)</code></pre><p>Create a spherical volume in the geometric model <code>geo</code>, centered at <code>X</code> with radius <code>r</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the sphere will be added.</li><li><code>X::Vector{&lt;:Real}</code>: Sphere center coordinates <code>[x, y, z]</code>.</li><li><code>r::Real</code>: Sphere radius.</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the volume.</li></ul><p><strong>Returns</strong></p><ul><li><code>Volume</code>: The created spherical volume entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_stage-Tuple{Serendip.Analysis}"><a class="docstring-binding" href="#Serendip.add_stage-Tuple{Serendip.Analysis}"><code>Serendip.add_stage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_stage(ana::Analysis; name=&quot;&quot;, nincs=1, nouts=0, tspan=0.0, activate=:all, deactivate=:none)</code></pre><p>Append a new numerical analysis stage to the <code>AnalysisData</code> container.</p><p>A stage defines a phase of the simulation with specific load increments, output frequencies,  and topological changes (activating or deactivating elements).</p><p><strong>Arguments</strong></p><ul><li><code>ana::Analysis</code>: The parent analysis object containing the model and data.</li></ul><p><strong>Keywords</strong></p><ul><li><code>name::String</code>: User-defined label for the stage (default = <code>&quot;&quot;</code>).</li><li><code>nincs::Int</code>: Number of increments to reach the end of the stage (default = <code>1</code>).</li><li><code>nouts::Int</code>: Number of output steps during the stage (default = <code>0</code>).</li><li><code>tspan::Float64</code>: Physical time span for transient analysis (default = <code>0.0</code>).</li><li><code>activate::Any</code>: Selector or filter to enable specific elements at the start of the stage (default = <code>:all</code>).</li><li><code>deactivate::Any</code>: Selector or filter to disable specific elements at the start of the stage (default = <code>:all</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Stage</code>: The newly created and initialized stage object.</li></ul><p><strong>Notes</strong></p><ul><li>The function automatically assigns a stage ID based on the current number of stages in <code>ana.data.stages</code>.</li><li>Elements are selected via the <code>select</code> function using the provided <code>activate</code> and <code>deactivate</code> filters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_surface_filling-Tuple{GeoModel, Serendip.Loop}"><a class="docstring-binding" href="#Serendip.add_surface_filling-Tuple{GeoModel, Serendip.Loop}"><code>Serendip.add_surface_filling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_surface_filling(geo, loop; tag=&quot;&quot;)</code></pre><p>Create a filled surface bounded by the closed <code>loop</code>. Useful for non-planar or curved boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the surface will be added.</li><li><code>loop::Loop</code>: Boundary curve loop defining the surface perimeter.</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the surface.</li></ul><p><strong>Returns</strong></p><ul><li><code>Surface</code>: The created filled surface entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_surface_loop-Tuple{Vector{Surface}}"><a class="docstring-binding" href="#Serendip.add_surface_loop-Tuple{Vector{Surface}}"><code>Serendip.add_surface_loop</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_surface_loop(surfaces)</code></pre><p>Create a surface loop from a collection of <code>surfaces</code>. Used to define closed regions for volume creation.</p><p><strong>Arguments</strong></p><ul><li><code>surfaces::Vector{Surface}</code>: List of surfaces forming a closed shell.</li></ul><p><strong>Returns</strong></p><ul><li><code>SurfaceLoop</code>: The created surface loop entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.add_volume-Tuple{GeoModel, Vector{Serendip.SurfaceLoop}}"><a class="docstring-binding" href="#Serendip.add_volume-Tuple{GeoModel, Vector{Serendip.SurfaceLoop}}"><code>Serendip.add_volume</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_volume(geo, sloops; tag=&quot;&quot;)</code></pre><p>Create a 3D volume in the geometric model <code>geo</code>, bounded by the given surface loops <code>sloops</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the volume will be added.</li><li><code>sloops::Vector{SurfaceLoop}</code>: List of closed surface loops defining the volume boundary.</li><li><code>tag::String=&quot;&quot;</code>: Optional user-defined identifier for the volume.</li></ul><p><strong>Returns</strong></p><ul><li><code>Volume</code>: The created volume entity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.array-Tuple{Block}"><a class="docstring-binding" href="#Serendip.array-Tuple{Block}"><code>Serendip.array</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array(block::Block; nx=1, ny=1, nz=1, dx=0.0, dy=0.0, dz=0.0)</code></pre><p>Creates a rectangular array of blocks of size <code>nx</code>×<code>ny</code>×<code>nz</code> using copies of <code>block</code> spaced at <code>dx</code>, <code>dy</code> and <code>dz</code>. The original <code>bĺock</code> is considered as part of the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; block = Block([ 0 0; 1 1 ], nx=3, ny=3);

julia&gt; blocks = array(block, nx=2, ny=2, dx=1, dy=1);

julia&gt; length(blocks)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.cut!"><a class="docstring-binding" href="#Serendip.cut!"><code>Serendip.cut!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cut!(table::DataTable, field, value=0.0; after=false)</code></pre><p>Cut a DataTable object at a given value of a field. If <code>after</code> is true, the DataTable is cut after the given value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.cut-Tuple{GeoModel, Any, Any}"><a class="docstring-binding" href="#Serendip.cut-Tuple{GeoModel, Any, Any}"><code>Serendip.cut</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cut(geo, ents1, ents2; remove_object=false, remove_tool=true, tag=&quot;&quot;)</code></pre><p>Boolean cut of <code>ents1</code> by <code>ents2</code> in the geometric model <code>geo</code>.   All entities in each set must have the same topological dimension.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the operation occurs.</li><li><code>ents1</code>: Objects to be cut (all same dimension).</li><li><code>ents2</code>: Tools that cut <code>ents1</code> (all same dimension as <code>ents1</code>).</li><li><code>remove_object::Bool=false</code>: If <code>true</code>, remove original objects.</li><li><code>remove_tool::Bool=true</code>: If <code>true</code>, remove tool entities.</li><li><code>tag::String=&quot;&quot;</code>: If non-empty, assigns this tag to all resulting entities.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Resulting entities from the cut.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.evaluate"><a class="docstring-binding" href="#Serendip.evaluate"><code>Serendip.evaluate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evaluate(expr, vars...)</code></pre><p>Returns the result of the arithmetic expression <code>expr</code> using values defined in <code>vars</code> if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.extrude-Tuple{Block}"><a class="docstring-binding" href="#Serendip.extrude-Tuple{Block}"><code>Serendip.extrude</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EXTRUDE</code></pre><p>Gets a 3D <code>Block</code> by extruding a 2D <code>block</code> in the direction given by <code>axis</code> and a distance <code>length</code>. It also sets the number of divisions <code>n</code> in the extruded direction.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; block2d = Block([ 0 0; 1 1 ], nx=3, ny=4, shape=QUAD8);
julia&gt; block3d = extrude(block2d, axis=[0,0,1], length=1, n=5)
Block
  nodes: 8-element Vector{Node}:
    1: Node  id=1
    2: Node  id=2
    3: Node  id=3
    4: Node  id=4
    5: Node  id=5
    6: Node  id=6
    7: Node  id=7
    8: Node  id=8
  shape: CellShape  name=&quot;HEX8&quot;
  cellshape: CellShape  name=&quot;HEX20&quot;
  nx: 3
  ny: 4
  nz: 5
  rx: 1.0
  ry: 1.0
  rz: 1.0
  tag: &quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.extrude-Tuple{GeoModel, Any, Any}"><a class="docstring-binding" href="#Serendip.extrude-Tuple{GeoModel, Any, Any}"><code>Serendip.extrude</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extrude(geo, ents, A; num_elements=[], heights=[], recombine=false)</code></pre><p>Extrude one or more entities <code>ents</code> in the geometric model <code>geo</code> along vector <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing the source entities.</li><li><code>ents</code>: A single entity or a vector of entities to extrude.</li><li><code>A::AbstractVector{&lt;:Real}</code>: Extrusion vector <code>[dx, dy, dz]</code>.</li><li><code>num_elements::Vector{Int}=[]</code>: Optional layer counts per step for transfinite extrusion.</li><li><code>heights::Vector{&lt;:Real}=[]</code>: Optional layer heights per step. Must match <code>num_elements</code> if provided.</li><li><code>recombine::Bool=false</code>: If <code>true</code>, recombine into quads/hexas where possible.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Newly created entities resulting from the extrusion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.extrude-Tuple{Mesh}"><a class="docstring-binding" href="#Serendip.extrude-Tuple{Mesh}"><code>Serendip.extrude</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extrude(mesh; length=1.0, n=1, axis=nothing, quiet=true, lagrangian=false)</code></pre><p>Generates a 3D mesh by extruding a planar <code>mesh</code> using a direction <code>axis</code>, a <code>length</code> and a number of divisions <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.fillet"><a class="docstring-binding" href="#Serendip.fillet"><code>Serendip.fillet</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fillet(geo, volumes, curves, radii; remove_volume=true)</code></pre><p>Apply edge fillets of given <code>radii</code> to <code>curves</code> on <code>volumes</code> in the geometric model <code>geo</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the operation occurs.</li><li><code>volumes</code>: A volume or vector of volumes to modify.</li><li><code>curves</code>: A curve or vector of curves to fillet.</li><li><code>radii</code>: A radius or vector of radii corresponding to <code>curves</code>.</li><li><code>remove_volume::Bool=true</code>: If <code>true</code>, remove original volumes.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Resulting modified entities after filleting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.fragment-Tuple{GeoModel, Any, Any}"><a class="docstring-binding" href="#Serendip.fragment-Tuple{GeoModel, Any, Any}"><code>Serendip.fragment</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fragment(geo, ents1, ents2; remove_object=true, remove_tool=true, tag=&quot;&quot;)</code></pre><p>Mutually fragment <code>ents1</code> and <code>ents2</code> in the geometric model <code>geo</code>, splitting them at intersections.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the operation occurs.</li><li><code>ents1</code>: First set of entities.</li><li><code>ents2</code>: Second set of entities.</li><li><code>remove_object::Bool=true</code>: If <code>true</code>, remove original objects.</li><li><code>remove_tool::Bool=true</code>: If <code>true</code>, remove tool entities.</li><li><code>tag::String=&quot;&quot;</code>: If non-empty, assigns this tag to all resulting entities.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: All resulting fragmented entities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.fuse-Tuple{GeoModel, Any, Any}"><a class="docstring-binding" href="#Serendip.fuse-Tuple{GeoModel, Any, Any}"><code>Serendip.fuse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fuse(geo, ents1, ents2; remove_object=true, remove_tool=true, tag=&quot;&quot;)</code></pre><p>Boolean union of <code>ents1</code> and <code>ents2</code> in the geometric model <code>geo</code>.   All entities in each set must have the same topological dimension.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model where the operation occurs.</li><li><code>ents1</code>: First set of entities (same dimension).</li><li><code>ents2</code>: Second set of entities (same dimension).</li><li><code>remove_object::Bool=true</code>: If <code>true</code>, remove original objects.</li><li><code>remove_tool::Bool=true</code>: If <code>true</code>, remove tool entities.</li><li><code>tag::String=&quot;&quot;</code>: If non-empty, assigns this tag to all resulting entities.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Resulting fused entities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.get_values-Tuple{Element}"><a class="docstring-binding" href="#Serendip.get_values-Tuple{Element}"><code>Serendip.get_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_values(elem::Element)</code></pre><p>Returns a <code>DataTable</code> containing state variable values at all integration points of the given element.</p><p><strong>Arguments</strong></p><ul><li><code>elem::Element</code>: The element whose integration point values are to be retrieved.</li></ul><p><strong>Returns</strong></p><ul><li><code>DataTable</code>: A table with one row per integration point and columns for each state variable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.laplacian_smooth!-Tuple{Mesh}"><a class="docstring-binding" href="#Serendip.laplacian_smooth!-Tuple{Mesh}"><code>Serendip.laplacian_smooth!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>laplacian_smooth!(mesh; maxit, verbose, mintol, tol, savesteps, savedata, filekey, smart, weighted)</p><p>Smooths a finite element mesh using Laplacian smoothing (standard, weighted, smart).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.mirror-NTuple{5, Any}"><a class="docstring-binding" href="#Serendip.mirror-NTuple{5, Any}"><code>Serendip.mirror</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mirror(ents, a, b, c, d)</code></pre><p>Mirror one or more entities <code>ents</code> with respect to the plane <code>a*x + b*y + c*z + d = 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ents</code>: A single entity or a vector of entities to mirror.</li><li><code>a::Real</code>: Plane coefficient for <code>x</code>.</li><li><code>b::Real</code>: Plane coefficient for <code>y</code>.</li><li><code>c::Real</code>: Plane coefficient for <code>z</code>.</li><li><code>d::Real</code>: Plane offset.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.mirror-Tuple{Block}"><a class="docstring-binding" href="#Serendip.mirror-Tuple{Block}"><code>Serendip.mirror</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mirror</code></pre><p>Creates a new Block by mirroring <code>block</code> according to a plane defined by a normal <code>axis</code> and <code>base</code> point.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; block1 = Block([ 0 0; 2 1; 1 1; 0 1], nx=2, ny=2);
julia&gt; block2 = mirror(block1, axis=[1,1], base=[2,1])
Block
  nodes: 4-element Vector{Node}:
    1: Node  id=1
    2: Node  id=2
    3: Node  id=3
    4: Node  id=4
  shape: CellShape  name=&quot;QUAD4&quot;
  cellshape: CellShape  name=&quot;QUAD4&quot;
  nx: 2
  ny: 2
  nz: 1
  rx: 1.0
  ry: 1.0
  rz: 1.0
  tag: &quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.move-Tuple{Block}"><a class="docstring-binding" href="#Serendip.move-Tuple{Block}"><code>Serendip.move</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">move</code></pre><p>Moves a <code>block</code> position by updating its coordinates according to <code>dx</code>, <code>dy</code> and <code>dz</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; block = Block([ 0 0 0; 1 1 1], nx=1, ny=2, nz=3)

julia&gt; move(block, dx=0.5, dy=1.0)

julia&gt; block
Block
    nodes: 8-element Vector{Node}:
        1: Node  id=1
        2: Node  id=2
        3: Node  id=3
        4: Node  id=4
        5: Node  id=5
        6: Node  id=6
        7: Node  id=7
        8: Node  id=8
    shape: CellShape  name=&quot;HEX8&quot;
    cellshape: CellShape  name=&quot;HEX8&quot;
    nx: 1
    ny: 2
    nz: 3
    rx: 1.0
    ry: 1.0
    rz: 1.0
    tag: &quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.move-Tuple{Mesh}"><a class="docstring-binding" href="#Serendip.move-Tuple{Mesh}"><code>Serendip.move</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>move(mesh, [dx=0.0,] [dy=0.0,] [dz=0.0])</code></p><p>Moves a Mesh object <code>mesh</code>. Also returns a reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.permute_coordinates-Tuple{Mesh, String}"><a class="docstring-binding" href="#Serendip.permute_coordinates-Tuple{Mesh, String}"><code>Serendip.permute_coordinates</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">permute_coordinates(mesh, order)</code></pre><p>Changes the coordinate axes of a <code>mesh</code> according to a new <code>order</code> given as a string.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">    mesh = Mesh(Block([0 0; 1 1], nx=2, ny=2));
    permute_coordinates(mesh, &quot;zxy&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.polar-Tuple{AbstractArray}"><a class="docstring-binding" href="#Serendip.polar-Tuple{AbstractArray}"><code>Serendip.polar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polar

Creates a `polar` array from `blocks` by rotating it
around `axis` along an `angle` domain. `n` representes
the number of cells in the polar direction.
The elements in `blocks` can be `Block` objects or even lists of
`Block` objects.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.polar-Tuple{Block}"><a class="docstring-binding" href="#Serendip.polar-Tuple{Block}"><code>Serendip.polar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polar

Creates a `polar` array using copies of `block` by rotating it
around `axis` along an `angle` domain. `n` representes
the number of cells in the polar direction.

# Examples

```julia
julia&gt; block = Block([ 0 0; 1 0; 0.707 0.707; 0 1; 0.5 0; 0.924 0.383; 0.382 0.924; 0.354 0.354 ], nx=3, ny=3);

julia&gt; blocks = polar(block, base=[ 0, 0 ,0 ], axis=[ 0, 0, 1 ], angle=360, n=4);

julia&gt; length(blocks)
4
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.rand_mesh-Tuple{Vararg{Int64}}"><a class="docstring-binding" href="#Serendip.rand_mesh-Tuple{Vararg{Int64}}"><code>Serendip.rand_mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rand_mesh(n...; shape=nothing)</code></pre><p>Generate a random structured mesh of unit size in 2D or 3D.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int...</code>: Number of elements in each spatial direction.  <ul><li>For 2D: <code>(nx, ny)</code>  </li><li>For 3D: <code>(nx, ny, nz)</code></li></ul></li><li><code>shape</code>: Optional element type.   If not provided, a random element shape is chosen among   <code>(TRI3, TRI6, QUAD4, QUAD8)</code> for 2D, or   <code>(TET4, TET10, HEX8, HEX20)</code> for 3D.</li></ul><p><strong>Returns</strong></p><ul><li><code>Mesh</code>: A randomly generated finite element mesh.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.resize"><a class="docstring-binding" href="#Serendip.resize"><code>Serendip.resize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">resize(table::DataTable, n::Int=0; ratio=1.0)

Resize a DataTable object to `n` rows. If `n` is not provided, the number of rows is calculated using `ratio` parameter.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.revolve"><a class="docstring-binding" href="#Serendip.revolve"><code>Serendip.revolve</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">revolve(geo, ents, X, A, angle; num_elements=[], heights=[], recombine=false)</code></pre><p>Revolve one or more entities <code>ents</code> in the geometric model <code>geo</code> by <code>angle</code> radians around the axis defined by point <code>X</code> and direction <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing the source entities.</li><li><code>ents</code>: A single entity or a vector of entities to revolve.</li><li><code>X::AbstractVector{&lt;:Real}</code>: Point on the rotation axis <code>[x, y, z]</code>.</li><li><code>A::AbstractVector{&lt;:Real}</code>: Axis direction vector <code>[ax, ay, az]</code>.</li><li><code>angle::Real</code>: Sweep angle in radians.</li><li><code>num_elements::Vector{Int}=[]</code>: Optional layer counts per step.</li><li><code>heights::Vector{&lt;:Real}=[]</code>: Optional layer heights per step.</li><li><code>recombine::Bool=false</code>: If <code>true</code>, recombine into quads/hexas where possible.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Newly created entities resulting from the revolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.revolve-Tuple{Mesh}"><a class="docstring-binding" href="#Serendip.revolve-Tuple{Mesh}"><code>Serendip.revolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">revolve(mesh; base=[0,0,0], axis=[0,0,1], minangle=0, maxangle=360, angle=360, n=8, collapse=true, lagrangian=false)</code></pre><p>Generates a 3D mesh by revolving a 1D o3 2D <code>mesh</code> using a <code>base</code> point, an <code>axis</code>, a rotation <code>angle</code> and a number of divisions <code>n</code>. If <code>collapse</code> is true, each element with concident nodes is collapsed into simpler element with fewer nodes. If lagrangian is true, lagrangian elements are generated when posible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.revolve-Tuple{Node}"><a class="docstring-binding" href="#Serendip.revolve-Tuple{Node}"><code>Serendip.revolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">revolve(node; base=[0,0,0], axis=[0,0,1], minangle=0, maxangle=360, angle=360, n=8)</code></pre><p>Generates a mesh composed by LIN3 elements by revolving a <code>node</code> using a <code>base</code> point, an <code>axis</code>, a rotation <code>angle</code> and a number of divisions <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.rotate-Tuple{Block}"><a class="docstring-binding" href="#Serendip.rotate-Tuple{Block}"><code>Serendip.rotate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rotate!</code></pre><p>Rotates <code>block</code> an <code>angle</code> (default 90 degrees) around an <code>axis</code> that passes by a <code>base</code> point.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; block = Block([ 0 0; 1 1 ], nx=2, ny=2);

julia&gt; get_coords(block)
4×3 Matrix{Float64}:
 0.0  0.0  0.0
 1.0  0.0  0.0
 1.0  1.0  0.0
 0.0  1.0  0.0

julia&gt; rotate(block, base=[ 0, 0, 0 ], axis=[ 0, 0, 1], angle=45);

julia&gt; get_coords(block)
4×3 Matrix{Float64}:
 0.0       0.0       0.0
 0.707107  0.707107  0.0
 0.0       1.41421   0.0
 0.0       0.707107  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.rotate-Tuple{GeoModel, Vararg{Any, 4}}"><a class="docstring-binding" href="#Serendip.rotate-Tuple{GeoModel, Vararg{Any, 4}}"><code>Serendip.rotate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rotate(geo, ents, X, A, angle)</code></pre><p>Rotate one or more entities <code>ents</code> in the geometric model <code>geo</code> by <code>angle</code> radians around the axis defined by point <code>X</code> and direction <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing the entities.</li><li><code>ents</code>: A single entity or a vector of entities to rotate.</li><li><code>X::AbstractVector{&lt;:Real}</code>: Point on the rotation axis <code>[x, y, z]</code>.</li><li><code>A::AbstractVector{&lt;:Real}</code>: Axis direction vector <code>[ax, ay, az]</code>.</li><li><code>angle::Real</code>: Rotation angle in radians.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.rotate-Tuple{Mesh}"><a class="docstring-binding" href="#Serendip.rotate-Tuple{Mesh}"><code>Serendip.rotate</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>rotate(mesh; base=[0,0,0], axis=[0,0,1], angle=90.0)</code></p><p>Rotates a Mesh object <code>mesh</code> according to a <code>base</code> point, an <code>axis</code> vector and an <code>angle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.save-Tuple{FEModel, String}"><a class="docstring-binding" href="#Serendip.save-Tuple{FEModel, String}"><code>Serendip.save</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save(domain, filename)</code></pre><p>Saves a domain object into a file. Available formats are vtu, vtk and xml.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.save-Tuple{Serendip.AbstractDomain, String}"><a class="docstring-binding" href="#Serendip.save-Tuple{Serendip.AbstractDomain, String}"><code>Serendip.save</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save(mesh, filename, quiet=true)</code></pre><p>Saves a mesh object into a file. Available formats are vtu and vtk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.scale-Tuple{Block}"><a class="docstring-binding" href="#Serendip.scale-Tuple{Block}"><code>Serendip.scale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scale</code></pre><p>Scales a <code>block</code> from the point <code>base</code> using the given <code>factor</code>. If <code>axis</code> is provided, the scaling is performent only in the <code>axis</code> direction.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; block = Block([ 0 0; 1 1 ], nx=2, ny=2);

julia&gt; get_coords(block)
4×3 Matrix{Float64}:
 0.0  0.0  0.0
 1.0  0.0  0.0
 1.0  1.0  0.0
 0.0  1.0  0.0

julia&gt; scale(block, factor=0.5, base=[ 0, 0 ], axis=[ 1, 0 ]);

julia&gt; get_coords(block)
4×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.5  0.0  0.0
 0.5  0.0  0.0
 0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.select-Tuple{Serendip.AbstractDomain, Symbol, Vararg{Union{Expr, String, Symbol, CellShape, Symbolic, NTuple{N, Symbolic} where N, Vector{&lt;:Real}}}}"><a class="docstring-binding" href="#Serendip.select-Tuple{Serendip.AbstractDomain, Symbol, Vararg{Union{Expr, String, Symbol, CellShape, Symbolic, NTuple{N, Symbolic} where N, Vector{&lt;:Real}}}}"><code>Serendip.select</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">select(domain::AbstractDomain, kind::Symbol, selectors...; invert=false, tag=&quot;&quot;)</code></pre><p>Filters entities from a finite element domain (<code>domain</code>) by type and selection criteria.</p><p><strong>Arguments</strong></p><ul><li><code>domain::AbstractDomain</code>: The mesh or domain containing entities.</li><li><code>kind::Symbol</code>: One of <code>:element</code>, <code>:face</code>, <code>:edge</code>, or <code>:node</code> to specify which entity to select.</li><li><code>selectors</code>: One or more selectors.</li></ul><p>Selectors can be:</p><ul><li><code>:all</code>             → select all elements (no filtering)</li><li><code>:bulk</code>, <code>:line</code>, <code>:contact</code>, <code>:cohesive</code>, <code>:line_interface</code>, <code>:tip</code> → select by element role</li><li><code>:active</code>          → select only active elements</li><li><code>:embedded</code>        → select embedded line elements (with couplings)</li><li><code>String</code>           → match element tag</li><li><code>Expr</code> or <code>Symbolic</code> → spatial condition using coordinates <code>x</code>, <code>y</code>, <code>z</code></li><li><code>Vector{Int}</code>      → list of element indices to select</li><li><code>NTuple{N, Symbolic}</code> → multiple symbolic coordinate conditions</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>invert::Bool</code>: If <code>true</code>, returns the entities not matching the selectors.</li><li><code>tag::String</code>: If non-empty, assigns this tag to all selected entities.</li></ul><p><strong>Returns</strong></p><ul><li>A list of selected entities of the specified kind.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.select-Tuple{Vector{&lt;:Serendip.AbstractCell}, Vararg{Union{Expr, String, Symbol, Symbolic, NTuple{N, Symbolic} where N, Vector{Int64}}}}"><a class="docstring-binding" href="#Serendip.select-Tuple{Vector{&lt;:Serendip.AbstractCell}, Vararg{Union{Expr, String, Symbol, Symbolic, NTuple{N, Symbolic} where N, Vector{Int64}}}}"><code>Serendip.select</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">select(elems::Vector{&lt;:AbstractCell}, selectors...; invert=false, tag=&quot;&quot;)</code></pre><p>Filters a list of finite element cells (<code>elems</code>) based on one or more <code>selectors</code>.</p><p>Selectors can be:</p><ul><li><code>:all</code>             → select all elements (no filtering)</li><li><code>:cont</code>, <code>:bulk</code>, <code>:line</code>, <code>:contact</code>, <code>:cohesive</code>, <code>:line_interface</code>, <code>:tip</code> → select by element role</li><li><code>:active</code>          → select only active elements</li><li><code>:embedded</code>        → select embedded line elements (with couplings)</li><li><code>String</code>           → match element tag</li><li><code>Expr</code> or <code>Symbolic</code> → spatial condition using coordinates <code>x</code>, <code>y</code>, <code>z</code></li><li><code>Vector{Int}</code>      → list of element indices to select</li><li><code>NTuple{N, Symbolic}</code> → multiple symbolic coordinate conditions</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>invert::Bool</code>: If <code>true</code>, returns the complement of the selected set.</li><li><code>tag::String</code>: If non-empty, assigns this tag to all selected elements.</li></ul><p><strong>Returns</strong></p><ul><li>A filtered list of elements matching the criteria.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.set_recombine-Tuple{GeoModel, Any}"><a class="docstring-binding" href="#Serendip.set_recombine-Tuple{GeoModel, Any}"><code>Serendip.set_recombine</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_recombine(geo, ent)</code></pre><p>Enable element recombination for a surface entity <code>ent</code> in the geometric model <code>geo</code>.   This converts triangular subdivisions into quadrilateral elements during meshing.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing the surface.</li><li><code>ent</code>: Surface entity where recombination is applied.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.set_refinement-Tuple{GeoModel, Vector{&lt;:Real}, Vararg{Real, 5}}"><a class="docstring-binding" href="#Serendip.set_refinement-Tuple{GeoModel, Vector{&lt;:Real}, Vararg{Real, 5}}"><code>Serendip.set_refinement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_refinement(geo, X, rx, ry, rz, size1, size2; gradient=0.1, roundness=0.5)</code></pre><p>Register a mesh-refinement field centered at <code>X</code>. The field targets element size <code>size1</code> near <code>X</code>, transitioning to <code>size2</code> away from it. The radii <code>rx</code>, <code>ry</code>, and <code>rz</code> set the extents along the x/y/z axes.</p><p><strong>Arguments</strong></p><ul><li><code>geo</code>::GeoModel            : geometry model.</li><li><code>X</code>::AbstractVector{&lt;:Real}: 3D center <code>[x, y, z]</code>.</li><li><code>rx</code>::Real                 : extent along x.</li><li><code>ry</code>::Real                 : extent along y.</li><li><code>rz</code>::Real                 : extent along z.</li><li><code>size1</code>::Real              : inner target size.</li><li><code>size2</code>::Real              : outer target size.</li></ul><p><strong>Keywords</strong></p><ul><li><code>gradient</code>::Real (&gt;0) = 0.1 : transition gradient from <code>size1</code> to <code>size2</code> (<code>0</code> = sharp, <code>1</code> = linear).</li><li><code>roundness</code>::Real ∈ [0,1] = 0.5 : shape of the refinement region (<code>0</code> = box-like, <code>1</code> = ellipsoidal).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">set_refinement(geo, [0.5, 0.5, 0.5], 10.0, 20.0, 15.0, 0.1, 0.5;
               gradient=0.5, roundness=0.8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.set_size-Tuple{GeoModel, Real}"><a class="docstring-binding" href="#Serendip.set_size-Tuple{GeoModel, Real}"><code>Serendip.set_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_size(geo::GeoModel, size::Real)</code></pre><p>Sets the maximum mesh size for all entities in the Gmsh-based geometry model.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: The geometry model whose mesh settings will be modified.</li><li><code>size::Real</code>: The desired global mesh size.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">set_size(geo, 0.05)  # Set global mesh size to 0.05 units</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.set_size-Tuple{GeoModel, Symbol, String, Real}"><a class="docstring-binding" href="#Serendip.set_size-Tuple{GeoModel, Symbol, String, Real}"><code>Serendip.set_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_size(geo, kind, tag, size)</code></pre><p>Assigns a local mesh size to all points on the boundary of entities selected by type (<code>kind</code>) and tag within a <code>GeoModel</code>.</p><p>This function selects entities of a specific geometric type (<code>:point</code>, <code>:edge</code>, <code>:surface</code>, <code>:volume</code>) and tag, and sets the mesh size at the corresponding points.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: The geometry model where the mesh size is applied.</li><li><code>kind::Symbol</code>: Type of geometric entity to target (<code>:point,</code><code>:edge</code>, <code>:face</code>, <code>:volume</code>).</li><li><code>tag::String</code>: Tag string used to select the target entities.</li><li><code>size::Real</code>: Target mesh size to assign at the boundary points of the selected entities.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">set_size(geo, :surface, &quot;foundation_zone&quot;, 0.05)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.set_size-Tuple{GeoModel, Union{Serendip.GeoEntity, Vector{&lt;:Serendip.GeoEntity}}, Real}"><a class="docstring-binding" href="#Serendip.set_size-Tuple{GeoModel, Union{Serendip.GeoEntity, Vector{&lt;:Serendip.GeoEntity}}, Real}"><code>Serendip.set_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_size(geo, target, size)</code></pre><p>Assigns a target mesh size to the point entities on the boundary of the given <code>target</code> geometry entity or entities. If a single <code>GeoEntity</code> is passed, it is internally wrapped in a vector.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: The geometry model where the mesh size will be assigned.</li><li><code>target::Union{GeoEntity,Vector{&lt;:GeoEntity}</code>: A single <code>GeoEntity</code> or a vector of them.</li><li><code>size::Real</code>: The target mesh size to assign to the boundary points of the given entities.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">set_size(geo, some_line_entity, 0.05)
set_size(geo, [curve1, surface1], 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.set_transfinite_curve-Tuple{GeoModel, Any, Any}"><a class="docstring-binding" href="#Serendip.set_transfinite_curve-Tuple{GeoModel, Any, Any}"><code>Serendip.set_transfinite_curve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_transfinite_curve(geo, curve, num_nodes)</code></pre><p>Define a transfinite discretization along a curve entity <code>curve</code> in the geometric model <code>geo</code>,   specifying the number of mesh nodes to distribute along it.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing the curve.</li><li><code>curve</code>: Curve entity (typically an <code>Edge</code>) to be meshed with transfinite spacing.</li><li><code>num_nodes::Int</code>: Number of nodes along the curve, including endpoints.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.set_transfinite_surface-Tuple{GeoModel, Any}"><a class="docstring-binding" href="#Serendip.set_transfinite_surface-Tuple{GeoModel, Any}"><code>Serendip.set_transfinite_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_transfinite_surface(geo, surface)</code></pre><p>Assign a transfinite mesh distribution to a surface entity <code>surface</code> in the geometric model <code>geo</code>.   Used to ensure structured meshing consistent with adjoining transfinite curves.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing the surface.</li><li><code>surface</code>: Surface entity to be meshed transfinetely.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.set_transfinite_volume-Tuple{GeoModel, Any}"><a class="docstring-binding" href="#Serendip.set_transfinite_volume-Tuple{GeoModel, Any}"><code>Serendip.set_transfinite_volume</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_transfinite_volume(geo, volume)</code></pre><p>Assign a transfinite mesh distribution to a volume entity <code>volume</code> in the geometric model <code>geo</code>.   Ensures structured, block-like hexahedral meshing compatible with transfinite boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing the volume.</li><li><code>volume</code>: Volume entity to be meshed using transfinite interpolation.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.slice-Tuple{Serendip.AbstractDomain}"><a class="docstring-binding" href="#Serendip.slice-Tuple{Serendip.AbstractDomain}"><code>Serendip.slice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">slice(mesh; base, axis)</code></pre><p>Generates a planar mesh by slicing a 3D <code>mesh</code> using a plane defined by a <code>base</code> point and an <code>axis</code>. The original nodal data is interpolated to the nodes of the resulting mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.split_by-Tuple{DataTable, String}"><a class="docstring-binding" href="#Serendip.split_by-Tuple{DataTable, String}"><code>Serendip.split_by</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">split_by(table::DataTable, col_name::String)</code></pre><p>Splits a DataTable into a vector of new DataTables based on the unique values in a specified column.</p><p>This is an efficient implementation that makes a single pass over the data to group row indices before creating the new tables. The resulting tables are not guaranteed to be in any specific order.</p><p><strong>Arguments</strong></p><ul><li><code>table::DataTable</code>: The input table to split.</li><li><code>col_name::String</code>: The name of the column whose values will be used to group the rows.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{DataTable}</code>: A vector of new <code>DataTable</code> objects, where each table corresponds to a unique value in the <code>col_name</code> column.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">header = [&quot;ID&quot;, &quot;Category&quot;, &quot;Value&quot;]
columns = [
    [1, 2, 3, 4, 5, 6],
    [&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;],
    [10.1, 20.2, 10.3, 30.1, 20.4, 10.5]
]
dt = DataTable(header, columns, name=&quot;SalesData&quot;)
grouped_tables = split_by(dt, &quot;Category&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Serendip.translate-Tuple{GeoModel, Vararg{Any, 4}}"><a class="docstring-binding" href="#Serendip.translate-Tuple{GeoModel, Vararg{Any, 4}}"><code>Serendip.translate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">translate(geo, ents, dx, dy, dz)</code></pre><p>Translate one or more entities <code>ents</code> in the geometric model <code>geo</code> by the displacement components <code>(dx, dy, dz)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>geo::GeoModel</code>: Geometry model containing the entities.</li><li><code>ents</code>: A single entity or a vector of entities to translate.</li><li><code>dx::Real</code>: Translation along the x-axis.</li><li><code>dy::Real</code>: Translation along the y-axis.</li><li><code>dz::Real</code>: Translation along the z-axis.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalForge/Serendip.jl">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/overview/">« Overview</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Tuesday 24 February 2026 02:05">Tuesday 24 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
